#
#    This file is part of the CCP1 Graphical User Interface (ccp1gui)
# 
#   (C) 2002-2005 CCLRC Daresbury Laboratory
# 
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
# 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Implements the GAMESS-UK specific calculation (Calc) and
calculation editor (CalcEd) classes
"""

import os
import string
import sys
import shutil
import socket

import Tkinter
import Pmw
import tkFileDialog
import viewer.help

from qm import *
from tools import *
from qmtools import *
from filepunch import *
from jobmanager import *
from viewer.paths import root_path
from interfaces.gamessoutputreader import GamessOutputReader
from interfaces.jobsubEditor import RMCSEditor,NordugridEditor,GrowlEditor
from objects.file import *
#
from viewer.rc_vars import rc_vars
from viewer.paths import find_exe


MENU_ENER  = "Energy"
MENU_GRAD  = "Gradient"
MENU_OPT   = "Geometry Optimisation"
LOCALHOST = socket.gethostname()

class GAMESSUKCalc(QMCalc):
    """GAMESS-UK specifics."""
    def __init__(self, **kw):

        apply(QMCalc.__init__,(self,),kw)

        self.set_parameter("task",MENU_ENER)
        self.set_program('GAMESS-UK')
        self.set_title('This file was generated by the CCP1 GUI')

        # Job parameters
        self.set_parameter('submission',LOCALHOST)
        #
        # see the basismanager for the form of 
        # the basis structure
        #
        self.set_parameter("default_basis","sv 3-21G")
        self.set_parameter("basis",None)
        ####self.set_input("basis_atom",{})
        self.set_parameter("ECP",None)

        ####self.set_input("ECP_atom",{})
        self.set_parameter("dft_functional","BLYP")

        #Guess and Restart parameters
        self.set_parameter('restart',0)
        self.set_parameter('restart_type',0)
        self.set_parameter('job_name','unnamed')
        self.set_parameter('ed0_keep',0)
        self.set_parameter('ed0_path','?')
        self.set_parameter('ed2_keep',0)
        self.set_parameter('ed2_specify',0)
        self.set_parameter('ed2_path','?')
        self.set_parameter('ed3_keep',0)
        self.set_parameter('ed3_specify',0)
        self.set_parameter('ed3_path',0)
        self.set_parameter('ed7_keep',0)
        self.set_parameter('ed7_specify',0)
        self.set_parameter('ed7_path','?')
        self.set_parameter('ed14_keep',0)
        self.set_parameter('ed14_path','?')

        self.set_parameter('enter_sect1',0)
        self.set_parameter('enter_sect2',0)
#        self.set_parameter('super','full conventional')
#        self.set_parameter('bypass',0)
        self.set_parameter("guess_method","Compute")
        self.set_parameter("guess_comp","atoms")
        self.set_parameter("guess_sect1",1)
        self.set_parameter("guess_sect2",2)
        self.set_parameter("getq_block1",1)
        self.set_parameter("getq_block2",1)
        self.set_parameter("getq_sect1",1)
        self.set_parameter("getq_sect2",2)
        
        self.set_parameter("scf_method","RHF")
        self.set_parameter("scf_maxcyc",50)
        self.set_parameter("scf_threshold",6)
        self.set_parameter("scf_level_init",1.0)
        self.set_parameter("scf_level_it",10)
        self.set_parameter("scf_level_final",0.1)
        self.set_parameter("scf_bypass",0)
        self.set_parameter("dft_grid","medium")
        self.set_parameter("dft_weights","MHL8SSF")
        self.set_parameter("dft_grid_atom",{}) #This isn't used anywhere yet

        self.set_parameter("dft_radialgrid","default")
        self.set_parameter("dft_angulargrid","default")
        self.set_parameter("dft_radialgridpoints","100")
        self.set_parameter("dft_angulargridpoints","100")
        self.set_parameter("dft_jfit",0)
        self.set_parameter("dft_jbas","A1DGAUSS")
        self.set_parameter("dft_schwarz",6)
        
        self.set_parameter("postscf_method","None")
        self.set_parameter("predirectives",
             "#file ed3 ed3 keep\n"+
             "#memory 20000000\n"+
             "#time 600\n")
        self.set_parameter("classidirectives",
             "#restart new\n#super off nosym\n"+
             "#integral high\n#accuracy 30 15\n#bypass one two\n"+
             "#mfile memory\n")
        self.set_parameter("predirectives","")
        self.set_parameter("basisdirectives","")
        self.set_parameter("classidirectives","")
        self.set_parameter("classiidirectives","")

        self.set_parameter("ana_homolumo",0)
        self.set_parameter("ana_homolumo1",0)
        self.set_parameter("ana_homolumo2",0)
        self.set_parameter("ana_homolumo3",0)
        self.set_parameter("ana_homolumo4",0)
        self.set_parameter("ana_homolumo5",0)
        self.set_parameter("ana_orbitals",[])
        self.set_parameter("ana_chargeden",0)
        self.set_parameter("ana_chargedengrad",0)
        self.set_parameter("ana_spinden",0)
        self.set_parameter("ana_frequencies",0)
        self.set_parameter("ana_hessian",0)
        self.set_parameter("ana_potential",0)
        self.set_parameter("ana_diffden",0)

        self.set_parameter('direct_scf',0);
        self.set_parameter('symmetry',1)
        self.set_parameter('adaption',0)
        self.set_parameter('use_ri',0)
        self.set_parameter('accuracy','medium')
        
        #Geometry optimisation parameters
        self.set_parameter('opt_jorgensen',0)
        self.set_parameter('opt_hess_update','default')
        self.set_parameter('opt_powell',0)
        self.set_parameter('opt_min_hess',0)
        self.set_parameter('opt_max_hess',0)
        self.set_parameter('opt_rfo',0)
        self.set_parameter('opt_rfomode','on')

        field = Field()
        field.dim[0] = 11
        field.dim[1] = 11
        field.dim[2] = 11
        self.set_parameter('grid',field)
        self.field_sized=0

        self.basis_manager = BasisManager()

        self.rungamess = None
        self.gamessuk_exe = None
        
        #Set up the keyword basis sets for GAMESS-UK
        m = self.basis_manager
        m.define_keyword_basis('sto3g',['h','he','li',' be','b','c','n','o','f','ne',
                                        'na','mg','al','si','p','s','cl','ar',
                                        'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                        'ga','ge','as','se','br','kr',
                                        'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                        'in','sn','sb','te','i','xe'],ecp=0)
        m.define_keyword_basis('sv 3-21G',['h','he','li','be','b','c','n','o','f','ne',
                                           'na','mg','al','si','p','s','cl','ar',
                                           'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                           'ga','ge','as','se','br','kr',
                                           'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                           'in','sn','sb','te','i','xe'],ecp=0)
        m.define_keyword_basis('sv 4-21G',['h','he','li','be','b','c','n','o','f','ne'],ecp=0)
        m.define_keyword_basis('sv 4-31G',['h','b','c','n','o','f','ne',
                                           'p','s','cl','ar'],ecp=0)#check li & be -see gamess manual-3.12 table3
        m.define_keyword_basis('sv 5-31G',['h','b','c','n','o','f'],ecp=0)#not sure about li & be -see gamess
        m.define_keyword_basis('sv 6-21G',['h','he','li','be','b','c','n','o','f','ne',
                                           'na','mg','al','si','p','s','cl','ar'],ecp=0)
        m.define_keyword_basis('sv 6-31G',['h','li','be','b','c','n','o','f','ne',
                                           'na','mg','al','si','p','s','cl','ar',
                                           'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn'],ecp=0)
        m.define_keyword_basis('sv 6-31G*',['h','li','be','b','c','n','o','f','ne',
                                           'na','mg','al','si','p','s','cl','ar',
                                           'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn'],ecp=0)
        m.define_keyword_basis('midi1',['h','li','be','b','c','n','o','f','ne',
                                        'na','mg','al','si','p','s','cl','ar',
                                        'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                        'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('midi4',['h','li','be','b','c','n','o','f','ne',
                                        'na','mg','al','si','p','s','cl','ar',
                                        'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                        'ga','ge','as','se','br','kr'],ecp=0)

        #not sure about bi&bi for these 2- see GAMESS manual ch3/node12, table 3
        m.define_keyword_basis('sv dunning',['h','li','be','b','c','n','o','f','ne',
                                             'al','si','p','s','cl',
                                             'sc','ti','v','cr','mn','fe','co','ni','cu',
                                             'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('sv ahlrichs',['h','he','li','be','b','c','n','o','f','ne',
                                              'na','mg','al','si','p','s','cl','ar',
                                              'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                              'ga','ge','as','se','br','kr'],ecp=0)

        m.define_keyword_basis('dz dunning',['h','li','be','b','c','n','o','f','ne',
                                             'al','si','p','s','cl','ar',
                                             'sc','ti','v','cr','mn','fe','co','ni','cu','zn'],ecp=0)
        m.define_keyword_basis('dz ahlrichs',['h','he','li','be','b','c','n','o','f','ne',
                                              'na','mg','al','si','p','s','cl','ar',
                                              'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                              'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('dzp dunning',['h','li','be','b','c','n','o','f','ne',
                                              'al','si','p','s','cl','ar',
                                              'sc','ti','v','cr','mn','fe','co','ni','cu','zn'],ecp=0)
        m.define_keyword_basis('dzp ahlrichs',['h','he','li','be','b','c','n','o','f','ne',
                                              'na','mg','al','si','p','s','cl','ar',
                                              'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                              'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('tzv dunning',['h','be','b','c','n','o','f','ne',
                                              'al','si','p','s','cl','ar',
                                              'sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                              'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('tzv ahlrichs',['h','he','li','be','b','c','n','o','f','ne',
                                               'na','mg','al','si','p','s','cl','ar',
                                               'sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                               'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('tzvp dunning',['h','be','b','c','n','o','f','ne',
                                               'al','si','p','s','cl','ar',
                                               'sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                               'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('tzvp ahlrichs',['h','he','li','be','b','c','n','o','f','ne',
                                                'na','mg','al','si','p','s','cl','ar',
                                                'sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                                'ga','ge','as','se','br','kr'],ecp=0)


        m.define_keyword_basis('tzv 6-311G',['h','he','li','be','b','c','n','o','f','ne',
                                             'na','mg','al','si','p','s','cl','ar'],ecp=0)
        
        m.define_keyword_basis('tzvp 6-311G*',['h','he','li','be','b','c','n','o','f','ne',
                                               'na','mg','al','si','p','s','cl','ar'],ecp=0)

        m.define_keyword_basis('cc-pvdz',['h','he','li','be','b','c','n','o','f','ne',
                                          'na','al','si','p','s','cl','ar',
                                          'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('cc-pvtz',['h','he','li','be','b','c','n','o','f','ne',
                                          'na','al','si','p','s','cl','ar',
                                          'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('cc-pvqz',['h','he','li','be','b','c','n','o','f','ne',
                                          'na','al','si','p','s','cl','ar',
                                          'ga','ge','as','se','br','kr'],ecp=0)
        m.define_keyword_basis('cc-pv5z',['h','he','li','be','b','c','n','o','f','ne',
                                          'na','al','si','p','s','cl','ar',
                                          'ga','ge','as','se','br','kr'],ecp=0)

        #ECP Basis sets start here:
        m.define_keyword_basis('ecp sbjkc',['li','be','b','c','n','o','f','ne',
                                            'na','mg','al','si','p','s','cl','ar',
                                            'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                            'ga','ge','as','se','br','kr',
                                            'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                            'in','sn','sb','te','i','xe',
                                            'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy','ho','er','tm','yb','lu',
                                            'hf','ta','w','re','os','ir','pt','au','hg',
                                            'tl','pb','bi','po','at','rn'],ecp=1)
        
        m.define_keyword_basis('ecp lanl',['li','be','b','c','n','o','f','ne',
                                           'na','mg','al','si','p','s','cl','ar',
                                           'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                           'ga','ge','as','se','br','kr',
                                           'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                           'in','sn','sb','te','i','xe',
                                           'cs','ba','la',
                                           'hf','ta','w','re','os','ir','pt','au','hg',
                                           'tl','pb','bi'],ecp=1)
        
        m.define_keyword_basis('ecp lanl2',['h','li','be','b','c','n','o','f','ne'
                                            'na','mg','al','si','p','s','cl','ar',
                                            'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                            'ga','ge','as','se','br','kr',
                                            'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                            'in','sn','sb','te','i','xe',
                                            'cs','ba','la',
                                            'hf','ta','w','re','os','ir','pt','au','hg',
                                            'pb','bi','u','np','pu'],ecp=1)

        m.define_keyword_basis('ecp crenbl',['li','be','b','c','n','o','f','ne',
                                             'na','mg','al','si','p','s','cl','ar',
                                             'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                             'ga','ge','as','se','br','kr',
                                             'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                             'in','sn','sb','te','i','xe',
                                             'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy','ho','er','tm','yb','lu',
                                             'hf','ta','w','re','os','ir','pt','au',
                                             'pb','bi','po','at','rn',
                                             'fr','ra','ac',
                                             'th','pa','u','np','pu','am','cm','bk','cf','es','fm','md','no','lw'],ecp=1)

        m.define_keyword_basis('ecp crenbs',['sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                             'y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                             'la',
                                             'hf','ta','w','re','os','ir','pt','au','pb','bi','po','at','rn'],ecp=1)

        m.define_keyword_basis('ecp strlc',['li','be','b','c','n','o','f','ne',
                                            'na','mg','al','si','p','s','cl','ar','k','ca',
                                            'zn','ga','ge','as','se','br','kr','rb','sr',
                                            'in','sn','sb','te','i','xe',
                                            'cs','ba','hg','tl','pb','bi','po','at','rn',
                                            'ac','th','pa','u','np','pu','am','cm','bk','cf','es','fm','md','no','lw'],ecp=1)
        
        m.define_keyword_basis('ecp strsc',['k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                            'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                            'cs','ba','ce','pr','nd','pm','sm','eu','gd','tb','dy','ho','er','tm','yb',
                                            'hf','ta','w','re','os','ir','pt','au',
                                            'hg','ac','th','pa','u','np','pu','am','cm','bk','cf','es','fm','md','no','lw'],ecp=1)



    def get_editor_class(self):
        return GAMESSUKCalcEd

    def WriteInput(self):
        """Write the GAMESS-UK input file"""

        self.GetModel()
        mol_name = self.get_input("mol_name")
        mol_obj  = self.get_input("mol_obj")
        job_name = self.get_parameter("job_name")
        directory = self.get_parameter("directory")

        filename = directory+os.sep+job_name+'.in'
       
        writeinput_err = self.__WriteInput(mol_obj,filename)
        if writeinput_err:
            return

        # load contents of input for viewing
        file = open(directory+os.sep+job_name+'.in','r')
        input = file.readlines()
        self.set_input("input_file",input)
        file.close()

    def makejob(self,writeinput=1,graph=None):
        """Prepare the GAMESS-UK job:
        1) Generate the input-file
        2) Construct the sequence of job steps
        """
        #Get an editor instance to pop up tk-error widgets
        ed = self.get_editor()

        self.GetModel()
        mol_name = self.get_input("mol_name")
        job_name = self.get_parameter("job_name")
        directory = self.get_parameter("directory")

        if writeinput:
            filename = directory+os.sep+job_name+'.in'
            mol_obj  = self.get_input("mol_obj")
            writeinput_err = self.__WriteInput(mol_obj,filename)

            if writeinput_err:
                return
            
            # load contents of input for viewing
            file = open(directory+os.sep+job_name+'.in','r')
            input = file.readlines()
            self.set_input("input_file",input)
            file.close()
        else:
            try:
                print directory,os.sep,job_name
                file = open(directory+os.sep+job_name+'.in','r')
            except IOError,e:
                print str(e)
                ed.Error("Trying to run a calculation with no input file!\n"+
                         "Please make sure you have written an input file.")
                return
                
        #
        #  Need to decide what kind of job run
        # 

        # Run job from the specified directory
        os.chdir(directory)
        
        submission_policy = self.get_parameter("submission")
        
        if submission_policy == LOCALHOST:
            job = jobmanager.BackgroundJob()            
        elif submission_policy == 'RMCS':
            try:
                job = jobmanager.RMCSJob()
            except Exception,e:
                ed.Error(e)
                return
        elif submission_policy == 'Nordugrid':
            try:
                job = jobmanager.NordugridJob()
            except Exception,e:
                ed.Error(e)
                return
        elif submission_policy == 'GROWL':
            try:
                job = jobmanager.GrowlJob()
            except Exception,e:
                ed.Error(e)
                return

        # These steps carried out for all jobs
        job.name    = job_name
        stdin_file  = job_name+'.in'
        stdout_file = job_name+'.out'
        if submission_policy == 'GROWL':
            remote_punch  = 'ftn058'
            local_punch  = job_name+'.pun'
        else:
            local_punch = remote_punch  = job_name+'.pun'

        # Update any parameters the user may have set with the jobsubeditor widget
        if self.has_parameter('job_parameters'):
            ndict = self.get_parameter('job_parameters')
            job.update_job_parameters( ndict )

        job.add_step( DELETE_FILE,
                      'remove old output',
                      remote_filename=stdout_file,
                      kill_on_error=0)
        job.add_step( DELETE_FILE,
                      'remove old punch',
                      remote_filename=remote_punch,
                      kill_on_error=0)

        #HACK for hpcx
        if submission_policy == 'GROWL':
            if job.job_parameters['machine_list'][0] == 'login.hpcx.ac.uk': 
                fname = 'datain'
                shutil.copyfile( stdin_file,fname)
                stdin_file = fname
        
        job.add_step( COPY_OUT_FILE,
                      'transfer input',
                      local_filename=stdin_file)
            
        # Set up the run step depending on how we are submitting the job
        local_command = None
        local_command_args = None
        if submission_policy == LOCALHOST:
            # Determine how we will be running GAMESS-UK
            runmethod = self.get_runmethod( ErrorWidget = ed.Error)
            if not runmethod:
                return
            # See if we are keeping any files and set environment variables / get the rungamess string
            if self.rungamess:
                rungamess_cmdline = self.keepfiles()
                job_desc = 'Running GAMESS-UK with rungamess script'
                #local_command = self.rungamess+" " + rungamess_cmdline + " " + job_name
                local_command = self.rungamess
                local_command_args = rungamess_cmdline + [job_name]
            else:
                self.keepfiles()
                job_desc = 'Invoking GAMESS-UK binary directly'
                local_command = self.gamessuk_exe
            
        elif submission_policy == 'RMCS':
            job_desc = 'Running GAMESS-UK with RMCS'
            
        elif submission_policy == 'Nordugrid':
            job_desc = 'Running GAMESS-UK on Nordugrid'
            self.setup_nordugrid_job( job, punchfile=remote_punch, editor=ed )
                
        elif submission_policy == 'GROWL':
            job_desc = 'Running GAMESS-UK with GROWL'
            self.setup_growl_job( job )
            
        job.add_step( RUN_APP,
                      job_desc,
                      stdin_file = stdin_file,
                      stdout_file = stdout_file,
                      local_command = local_command,
                      local_command_args = local_command_args)

        job.add_step(COPY_BACK_FILE,'recover log',remote_filename=stdout_file)
        job.add_step(COPY_BACK_FILE,'recover punch',local_filename=local_punch,remote_filename=remote_punch)
        job.add_step(PYTHON_CMD,'load results',proc=lambda s=self,g=graph: s.endjob(g))
        job.add_tidy(self.endjob2)
        
        return job

    def endjob(self,graph):
        """This is executed in the slave thread when the job completes
        successfully.
        There should be no output from slaves unless activated from
        using the debug_slave flag.
        """
        return 0,""

    def endjob2(self,code=0):
        """This function is executed in the main thread"""

        if self.debug:
            print 'running endjob2 code=',code

        # load contents of listing for viewing
        if self.debug_slave:
            print 'endjob....'
        job_name = self.get_parameter("job_name")
        directory = self.get_parameter("directory")
        file = open(directory+'/'+job_name+'.out','r')
        self.ReadOutput(file)
        file.close()

        print 'scan output'
#        John's stuff
#
#  potential problem here with pickling the calculation
# ... all sorts of stuff inder there
#
        fname = job_name+'.out'
        try:
            g = GamessOutputReader(fname)
            #self.g = g

            # Hack
            self.final_energy = g.finalTotalEnergy

            if self.debug_slave:
                print 'scan output done'
        except:
            self.g = None
            if self.debug_slave:
                print 'scan output failed'

        # scan the punchfile ... only in case of success
        if code:
            return
        
        if self.__ReadPunch(directory+'/'+job_name+'.pun') != 1:
            raise JobError, "No molecular structure in Punchfile - check output"

        # problem here as that as we are running in a slave thread
        # we cannot use Tk .. so this is silent

        #o = File(directory+'/'+job_name+'.out',type=GAMESSUK_OUTPUT)
        # relative path should work here (better on windows, molden doesnt
        # tolerate embedded spaces)
        o = File(job_name+'.out',type=GAMESSUK_OUTPUT)
        self.results.append(o)

        ed = self.get_editor()
        if ed:
            if ed.graph:
                ed.graph.import_objects(self.results)
                txt = "Objects loaded from punchfile:"
                txt = txt  + "Structure update" + '\n'
                for r in self.results:
                    txt = txt + r.title + '\n'
                ed.Info(txt)
            # Update 
            if ed.update_func:
                o = self.get_input("mol_obj")
                #name = self.get_input("mol_name")
                ed.update_func(o)

    def get_runmethod(self, ErrorWidget=None):
        """ See if we can use rungamess, otherwise we invoke the gamessuk binary directly.
        """

        global rc_vars, find_exe
        self.rungamess = None

        # Windows
        if sys.platform[:3] == 'win':
            # Use the binary directly under Windows
            binary = self.get_gamessuk_exe()
            if binary:
                return binary
            else:
                if ErrorWidget:
                    msg = "Cannot find a working gamess.exe binary!\n" + \
                          "Please either set the gamessuk_exe variable in your ccp1guirc file.\n"+\
                          "Alternatively, set the environment variable GAMESS_BIN to point to\n"+\
                          "the directory containing the binary, or put the gamess binary in your path."
                    ErrorWidget(msg)
                return None
        else:
            # Unix / MacOSX code
            rungamess =  self.get_rungamess()
            if rungamess:
                return rungamess
            else:
                exe =  self.get_gamessuk_exe()
                if exe:
                    return exe
                else:
                    if ErrorWidget:
                        msg = "Cannot find a working rungamess script or gamess-uk binary!\n"+\
                              "Please either set the gamessuk_script or gamessuk_exe variables\n"+\
                              "in your ccp1guirc file or put the rungamess script in your path\n"+\
                              "Alternatively, set the environment variable GAMESS_EXE to point to\n"+\
                              "the binary, or put the gamess binary in your path."
                        ErrorWidget(msg)
                    return None

    def get_rungamess(self):
        """ Return the path to the rungamess script and set self.rungamess"""
        
        global rc_vars, find_exe
        self.rungamess = None

        # Windows
        if sys.platform[:3] == 'win':
            print "No rungamess under Windows"
            return None
        else:
            # Unix / MacOSX code
            if rc_vars.has_key('gamessuk_script') and rc_vars['gamessuk_script']:
                script = rc_vars['gamessuk_script']
            else:
                print "No gamessuk_script set in rc file - checking in environment"
                script = find_exe( 'rungamess' )
                if script:
                    print "Found rungamess script: %s" % script

            if script:
                print "Checking rungamess script is suitable..."
                # We've found a script so check it's o.k. to use it
                # Check if rungamess -V works - this prints out the environment variables
                from jobmanager import subprocess
                cmd = script + " -V"
                p = subprocess.ForegroundPipe(cmd)
                code = p.run()
                dict = {}
                if p.error:
                    print "Error trying to check for rungamess!"
                    self.rungamess = None
                else:
                    for l in p.output:
                        w = l.split()
                        if len(w) == 2:
                            dict[w[0]]=w[1]
                    try:
                        test = dict['GAMESS_LIB']
                        self.rungamess = script
                    except KeyError:
                        print 'Key error checking for rungamess'
                        self.rungamess = None

            if self.rungamess:
                print "Using rungamess script: %s" % self.rungamess
                return self.rungamess
            else:
                print "No suitable rungamess script found."
                return None
                    

    def get_gamessuk_exe(self):
        """ Return the path to the gamess-uk executable and set self.gamessuk_exe"""
        
        global rc_vars, find_exe

        # Windows
        if sys.platform[:3] == 'win':
            if rc_vars.has_key('gamessuk_exe') and rc_vars['gamessuk_exe']:
                gamessuk_exe = rc_vars['gamessuk_exe']
                if os.access( gamessuk_exe, os.X_OK):
                    self.gamessuk_exe = gamessuk_exe
                    print "Using gamess-uk binary location from ccp1guirc file: %s"  % self.gamessuk_exe
                    return gamessuk_exe
                else:
                    print "GAMESS-UK binary from rc file: %s" % gamessuk_exe
                    print "Cannot be excuted!"
            
            # No path to gamessuk executable found in the ccp1guirc file or the file is not executable
            # so try to see if the environment variable has been set
            print "No gamessuk_exe set in rc file - checking in environment"
            try:
                gamessuk_dir=os.environ['GAMESS_BIN']
                gamessuk_exe= gamessuk_dir + os.sep + "gamess.exe"
                print "Checking binary ",gamessuk_exe
                if os.access( gamessuk_exe, os.X_OK):
                    self.gamessuk_exe = gamessuk_exe
                    print "Using gamess-uk binary: %s" % self.gamessuk_exe
                    return gamessuk_exe
            except KeyError:
                pass            

            # Now just trundle through the users' path looking for an executable
            print "No GAMESS_BIN environment variable set"
            print "Checking for gamess.exe binary in users path..."
            gamessuk_exe = find_exe( 'gamess.exe' )
            if gamessuk_exe:
                self.gamessuk_exe = gamessuk_exe
                print "Using gamess-uk binary from users path: %s" % self.gamessuk_exe
                return gamessuk_exe
            else:
                # We couldn't find a binary so state this and return 1
                print "Could not find gamess.exe binary!"
                return None
        else:
            # Unix / MacOSX code
            if rc_vars.has_key('gamessuk_exe') and rc_vars['gamessuk_exe']:
                gamessuk_exe = rc_vars['gamessuk_exe']
                print "Checking binary from ccp1guirc file...",gamessuk_exe
                if os.access( gamessuk_exe, os.X_OK):
                    self.gamessuk_exe = gamessuk_exe
                    print "Using gamess-uk binary location from ccp1guirc file: %s"  % self.gamessuk_exe
                    return gamessuk_exe
            else:
                # No path to gamessuk executable found in the ccp1guirc file
                # so try to see if the environmen variable has been set
                print "No gamessuk_exe set in rc file - checking in environment"
                try:
                    gamessuk_exe=os.environ['GAMESS_EXE']
                    print "Checking binary GAMESS_EXE...",gamessuk_exe
                    if os.access( gamessuk_exe, os.X_OK):
                        self.gamessuk_exe = gamessuk_exe
                        print "Using gamess-uk binary: %s"  % self.gamessuk_exe
                        return gamessuk_exe
                    else:
                        print "GAMESS-UK binary %s cannot be executed!" % gamessuk_exe
                        pass
                except KeyError:
                    pass

                # Now just trundle through the path
                gamessuk_exe = find_exe( 'gamess' )
                if gamessuk_exe:
                    self.gamessuk_exe = gamessuk_exe
                    print "Using gamess-uk binary: %s" % self.gamessuk_exe
                    return gamessuk_exe
                else:
                    print "Cannot find a gamess-uk binary"
                    return None

    def setup_nordugrid_job(self,job, editor=None, punchfile=None):
        """ Setup a job to run on nordugrid - this checks count to see if we are running
            in serial or parallel. If in serial it copies the binary out, in parallel
            we set the runTimeEnvironment to look for GAMESS-UK
        """

        # Check the rc_vars to see if we need to set any variables
        if job.job_parameters['count'] == '1':
            # On 1 proc therefore need to see if we have an executable to run on the machine
            # and if a gamessuk environment exists there. If not we copy out our own gamess-uk executable
            if not job.job_parameters['executable'] and not job.job_parameters['runTimeEnvironment']:
                # No executable set and no environment, so we need to copy out the executable
                executable = self.get_gamessuk_exe()
                if not executable:
                    if editor:
                        editor.Error( "Nordugrid Job cannot run as no ngrid excutable or runTimeEnvironment\n"+
                                      "has been set and no suitable executable can be found!")
                    return None

                # NOTE on running this at first got the error message:
                # "Server does not support executable from PATH"
                # So it looks like we'll have to copy the executable to this directory for now
                exe_name = os.path.basename(executable)
                exe_path = os.getcwd()+os.sep+exe_name
                if not executable == exe_path: # If these the same shutil complains
                    try:
                        shutil.copyfile( executable, exe_path )
                    except Exception,e:
                        if editor:
                            editor.Error("Error copying Nordugrid executable to working directory!\n- %s" % e )
                            return
                        
                job.job_parameters['executable'] = exe_name
                job.job_parameters['inputfiles'][exe_name] = None
                # hack
                if punchfile:
                    job.job_parameters['environment']['ftn058'] = punchfile
                if not job.job_parameters['memory']:
                    job.job_parameters['memory']='500' # Need as otherwise jobs die with Error 11
        else:
            # Running parallel GAMESS-UK so assume look for clusters with the correct environment
            if not job.job_parameters['runTimeEnvironment']:
                job.job_parameters['runTimeEnvironment'] = 'APPS/CHEM/GAMESS-UK-7.0-1.0'
            if not job.job_parameters['executable']:
                job.job_parameters['executable'] = "/usr/bin/time"
                
            job.job_parameters['environment']['ftn058'] = punchfile

    def setup_growl_job(self,job):
        """ Setup the job parameters to run a Growl job
        """
        #if punchfile:
        #    job.job_parameters['environment']['ftn058'] = punchfile

        # Make sure we run with the correct executable and with MPI if > 1 proc
        if job.job_parameters['count'] > 1:
            if not job.job_parameters['jobtype']:
                job.job_parameters['jobtype'] = 'mpi'
            if not job.job_parameters['executable']:
                job.job_parameters['executable'] = 'gamess-uk'
        else:
            if not job.job_parameters['executable']:
                job.job_parameters['executable'] = 'gamess'
            

    def get_theory(self):
        """Convenience function for ChemShell interface"""
        postscf_method = self.get_parameter("postscf_method")
        print postscf_method
        if postscf_method == "None":
            scf_method = self.get_parameter("scf_method")
            print scf_method
            if scf_method == "Direct DFT" or scf_method == "Direct UDFT":
                theory = self.get_parameter("dft_functional")
            else:
                theory = scf_method
        else:
            #print 'else clause'
            theory = postscf_method

        #print 'done',theory
        return theory

    def check_direct(self):
        """Convenience function for ChemShell interface"""
        scf_method = self.get_parameter("scf_method")
        if scf_method == "Direct DFT" or scf_method == "Direct UDFT" or \
               scf_method == "Direct RHF" or scf_method == "Direct UHF":
            return 1
        else:
            return 0
    

    def keepfiles(self):
        """Keep any files the user has selected.
           For Windoze and when running the GAMESS-UK environment directly, use environment variables,
           For rungamess, build up a string that can be appended to the rungamess command and use
           this as the return value of the function
        """

        rungamess_cmdline = []
        
        # Punch file - if not using rungamess, need to ensure that the punch file is named
        # after the job
        if not self.rungamess:
            jobname = self.get_parameter('job_name')
            punfile = jobname+".pun"
            os.putenv('ftn058',punfile)

        # Always need to use environment variables for ed0
        if self.get_parameter('ed0_keep'):
            ed0_path = self.get_parameter("ed0_path")
            os.putenv('ed0',ed0_path)

        # ed2
        if self.get_parameter('ed2_keep'):
            if self.get_parameter('ed2_specify'):
                ed2_path = self.get_parameter('ed2_path')
            else:
                dir = self.get_parameter('directory')
                stem = self.get_parameter('job_name')
                ed2_path = dir+os.sep+stem+'.ed2'
                
            if self.rungamess:
                #rungamess_cmdline += ' -k ed2='+ed2_path
                rungamess_cmdline += ['-k', 'ed2='+ed2_path]
            else:
                os.putenv('ed2',ed2_path)

        # ed3
        if self.get_parameter('ed3_keep') or self.get_parameter("guess_method") == "Dumpfile":
            if self.get_parameter('ed3_specify'):
                ed3_path = self.get_parameter('ed3_path')
            else:
                dir = self.get_parameter('directory')
                stem = self.get_parameter('job_name')
                ed3_path = dir+os.sep+stem+'.ed3'
                
            if self.rungamess:
                #rungamess_cmdline += ' -k ed3='+ed3_path
                rungamess_cmdline += ['-k','ed3='+ed3_path]
            else:
                os.putenv('ed3',ed3_path)
                
        # ed7
        if self.get_parameter('ed7_keep'):
            if self.get_parameter('ed7_specify'):
                ed7_path = self.get_parameter('ed7_path')
            else:
                dir = self.get_parameter('directory')
                stem = self.get_parameter('job_name')
                ed7_path = dir+os.sep+stem+'.ed7'
                
            if self.rungamess:
                #rungamess_cmdline += ' -k ed7='+ed7_path
                rungamess_cmdline += ['-k','ed7='+ed7_path]
            else:
                os.putenv('ed7',ed7_path)

        if self.get_parameter("guess_method") == "GETQ":
            if not self.get_parameter('ed14_keep') or self.get_parameter('ed14_path')[0] == '?':
                ed.Error("Using GETQ for guess but the location of ed14 is unspecified.\n"+
                         "Please go to the job tab and specify the location of the foreign dumpfile (ed14).")
                return
            else:
                if self.get_parameter('ed14_keep'):
                    if self.get_parameter('ed14_specify'):
                        ed14_path = self.get_parameter('ed14_path')
                    else:
                        dir = self.get_parameter('directory')
                        stem = self.get_parameter('job_name')
                        ed14_path = dir+os.sep+stem+'.ed14'

                    if self.rungamess:
                        #rungamess_cmd_line += ' -k ed14='+ed14_path
                        rungamess_cmd_line += ['-k','ed14='+ed14_path]
                    else:
                        os.putenv('ed14',ed14_path)

        if self.rungamess:
            return rungamess_cmdline
        else:
            return None

    def __WriteInput(self,mol,filename):
        
        #Get an editor object so we can pop up tk error widgets
        ed = self.get_editor()

        #Check the spin of the molecule is o.k. before we do owt else.
        if self.CheckSpin(show=1):
            return 1

        file = open(filename,'w') 
        
        task           = self.get_parameter("task")
        scf_method     = self.get_parameter("scf_method")
        postscf_method = self.get_parameter("postscf_method")
        #Set local flag for rhf/uhf
        if (scf_method == "RHF" or scf_method == "DFT" or scf_method == "GVB" or 
            scf_method == "Direct RHF" or scf_method == "Direct DFT"):
            scftype="rhf"
        elif (scf_method == "UHF" or scf_method == "UDFT" or 
            scf_method == "Direct UHF" or scf_method == "Direct UDFT"):
            scftype="uhf"
        #Set local flag for dft
        if (scf_method == "DFT" or scf_method == "UDFT" or 
            scf_method == "Direct DFT" or scf_method == "Direct UDFT"):
            dft=1
        else:
            dft=0
        
        file.write(self.get_parameter("predirectives"))
        guess_method = self.get_parameter("guess_method")
        
        if self.get_parameter("ana_hessian"):
            file.write('file ed2 test.ed2 keep\n')

        if (guess_method == 'Dumpfile'):
            file.write('restart new\n')

        file.write('title\n')
        file.write(self.get_title()+'\n')
        if task == MENU_OPT:
            file.write('punch coor conn title opti\n')
        else:
            file.write('punch coor conn title\n')

        if not self.get_parameter('symmetry'):
            file.write('nosym\n')
            file.write('adapt off\n')

        if self.get_parameter('scf_bypass'):
            if (scftype == "rhf"):
                file.write('bypass one\n')
            elif (scftype == "uhf"):
                file.write('bypass one two\n')

        file.write('mult '+str(self.get_parameter("spin"))+'\n')
        file.write('charge '+str(self.get_parameter("charge"))+'\n')

        #file.write(self.get_parameter("classidirectives"))

        request_z = 0

        if self.get_parameter('task') == MENU_OPT and self.get_parameter('optimiser') == 'Z-Matrix':
            request_z = 1

        write_x = 1

        if request_z == 1:
            # Try to load mixed coordinates from the Z-matrix editor
            z = 0
            for a in mol.atom:
                if a.zorc == 'z':
                    z = 1
            if z:
                # check if the first 3 atoms comply with the
                # zmatrix conventions
                if abs(mol.atom[0].coord[0]) > 0.0001 or \
                   abs(mol.atom[0].coord[1]) > 0.0001 or \
                   abs(mol.atom[0].coord[2]) > 0.0001 or \
                   abs(mol.atom[1].coord[0]) > 0.0001 or \
                   abs(mol.atom[1].coord[1]) > 0.0001 or \
                   abs(mol.atom[2].coord[1]) > 0.0001 :
                    mol.list()
                    ed.Error('Make sure the first 3 atoms obey the zmatrix conventions')
                    raise Exception, "Bad z-matrix"

                else:

                    # check for variables
                    counts = mol.counts()
                    print 'counts',counts
                    if counts[2] == 0:
                        ed.Error('Z-matrix has no variables')
                        raise Exception, "Bad z-matrix"

                    # we can write out and use the internals
                    write_x = 0
                    file.write('zmatrix angstrom\n')

                    txt = mol.output_zmat()
                    #check first line to see if it specifies cartesians
                    tlist = string.split(txt[0])
                    first = tlist[0]
                    if (first[0:4] == 'coor'):
                        file.write('cartesian\n')
                        
                    # skip the zmatrix card as we replaced it
                    txt.pop(0)
#                    txt.remove(0)

                    for field in txt:
                        check = field.split()
                        first = check[0]
                        if (first[0:4] == 'coor'):
                            file.write('cartesian\n')
                        elif (first[0:4] == 'zmat'):
                            file.write('internal\n')
                        else:
                            file.write(field + '\n')

        if write_x:
            # Geometry
            file.write('geometry angstrom')
            if self.get_parameter('task')==MENU_OPT and self.get_parameter('optimiser') == 'Z-Matrix':
                # we need automatic z-matrix generation
                file.write(' all')
            file.write('\n')
            for a in mol.atom:
##                 t = string.lower(a.symbol)[:2]
##                 if t[1:2] == string.upper(t[1:2]):
##                     t = t[:1]

                if a.get_number() > 0:
                    file.write(str(a.coord[0]) + ' ' +
                               str(a.coord[1]) + ' ' +
                               str(a.coord[2]) + ' ' +
                               str(a.get_number()) + ' ' +
                               a.name + '\n')
                else:
                    file.write(str(a.coord[0]) + ' ' +
                               str(a.coord[1]) + ' ' +
                               str(a.coord[2]) + ' ' +
                               str(a.partial_charge) + ' ' +
                               a.name + '\n')

        file.write('end\n')
        #
        #  BASIS directive
        #
        self._write_basis(file)

        self._write_ecp(file)

        #  Replacement Class II
        classii = self.get_parameter("classiidirectives")
        if classii != "":
            file.write(classii)
            return 0

        #
        #  RUNTYPE directives
        #
        if task == MENU_ENER:
            if postscf_method == 'CISD':
                file.write('runtype ci\n')
            elif postscf_method == 'CCSD' or postscf_method == 'CCSD(T)':
                file.write('runtype ci\n')
            else:
                file.write('runtype scf\n')
        elif task == MENU_GRAD:
            file.write('runtype gradient\n')
        elif task == 'hessian':
            file.write('runtype hessian\n')
        elif task == MENU_OPT:
            if self.get_parameter('optimiser') == 'Z-Matrix':
                if self.get_parameter('opt_jorgensen'):
                    if self.get_parameter('find_ts'):
                        file.write('runtype saddle jorgensen\n')
                        powell = self.get_parameter('opt_powell')
                        if powell:
                            file.write('powell\n')
                    else:
                        file.write('runtype optim jorgensen\n')
                        hessupdate = self.get_parameter('opt_hess_update')
                        if hessupdate != 'default':
                            file.write(str(hessupdate)+'\n')

                    #Now write out all other jorgensen options:
                    eigmin = self.get_parameter('opt_min_hess')
                    if eigmin:
                        file.write('eigmin '+str(eigmin)+'\n')
                    eigmax = self.get_parameter('opt_max_hess')
                    if eigmax:
                        file.write('eigmin '+str(eigmax)+'\n')
                    rfo = self.get_parameter('opt_rfo')
                    if rfo:
                        file.write('rfo '+str(self.get_parameter('opt_rfomode'))+'\n')
                        
                    
                else: # we're not using jorgensen
                    if self.get_parameter('find_ts'):
                        file.write('runtype saddle\n')
                    else:
                        file.write('runtype optim\n')
            else:
                file.write('runtype optx\n')

        #
        #  SCFTYPE directive
        #
        if postscf_method == "MP2":
            file.write('scftype mp2\n')
        elif postscf_method == "MP3":
            file.write('scftype mp3\n')
        elif postscf_method == "Direct MP2":
            file.write('scftype direct mp2\n')
        # Restricted
        elif (scf_method == "RHF" or scf_method == "DFT"):
            file.write('scftype rhf\n')
        elif (scf_method == "Direct RHF" or scf_method == "Direct DFT"):
            file.write('scftype direct rhf\n')
        #Unrestricted
        elif (scf_method == "UHF" or scf_method == "UDFT"):
            file.write('scftype uhf\n')
        elif (scf_method == "Direct UHF" or scf_method == "Direct UDFT"):
            file.write('scftype direct uhf\n')
        else:
            file.write('scftype rhf\n')

        #This is where all the DFT directives go
#        if scf_method == "DFT" or scf_method == "UDFT" or scf_method == "Direct DFT" or scf_method == "Direct UDFT"
        if dft:
            functional = self.get_parameter("dft_functional")
            accuracy   = self.get_parameter("dft_grid")
            weights    = self.get_parameter("dft_weights")
            
            #Map what's written in the menus to GAMESS-UK directives
            dft_dictionary={"Euler-MacLaurin": "euler",
                            "Mura-Knowles" : "log",
                            "Lebedev-Laikov": "lebedev",
                            "Gauss-Legendre" : "gausslegendre",
                            "Lebedev-Laikov": "lebedev",
                            "Gauss-Legendre" : "gausslegendre"}
            
            radialgrid = self.get_parameter("dft_radialgrid")
            angulargrid = self.get_parameter("dft_angulargrid")
            jfit = self.get_parameter("dft_jfit")
             
            file.write('dft '+str(functional)+'\n')
            file.write('dft quadrature '+str(accuracy)+'\n')
            if weights != "default":
                file.write('dft weights '+str(weights)+'\n')

            #if radial & angular grids not default specify type and no. points
            if radialgrid != "default":
                file.write('dft '+dft_dictionary[radialgrid]+
                           ' '+str(self.get_parameter("dft_radialgridpoints"))+'\n')
            if angulargrid != "default":
                file.write('dft '+dft_dictionary[angulargrid]+
                           ' '+str(self.get_parameter("dft_angulargridpoints"))+'\n')

            #if coulomb fitting  add aux basis and scwarz cutoff
            if jfit:
                file.write('dft jfit memory \n') #memory is default as GAMESS will
                                                 #recalualte the integrals anyway
                                                 #if they don't fit in memory.
                file.write('dft schwartz '+str(self.get_parameter("dft_schwarz"))+'\n')
                file.write('dft jbas '+str(self.get_parameter("dft_jbas"))+'\n')

        #SCF convergence options
#         if (scf_method == "RHF" or scf_method == "DFT" or 
#             scf_method == "Direct RHF" or scf_method == "Direct DFT"):
        if (scftype == "rhf"):
            file.write('level '+
                       str(self.get_parameter("scf_level_init"))+' '+
                       str(self.get_parameter("scf_level_it"))+' '+
                       str(self.get_parameter("scf_level_final"))+'\n')
            
#         elif (scf_method == "UHF" or scf_method == "UDFT" or
#               scf_method == "Direct UHF" or scf_method == "Direct UDFT"):
        elif (scftype == "uhf"):
            file.write('level '+
                       str(self.get_parameter("scf_level_init"))+' '+
                       str(self.get_parameter("scf_level_init"))+' '+
                       str(self.get_parameter("scf_level_it"))+' '+
                       str(self.get_parameter("scf_level_final"))+' '+
                       str(self.get_parameter("scf_level_final"))+'\n')
            
        file.write('maxcyc '+str(self.get_parameter("scf_maxcyc"))+'\n')
        file.write('thresh '+str(self.get_parameter("scf_threshold"))+'\n')

        if task == MENU_OPT:
            #If optimising with jorgensen algorithm, minmax not applicable
            if self.get_parameter('opt_jorgensen'):
                file.write('maxjorg '+str(self.get_parameter("max_opt_step"))+'\n')
            else:
                file.write('minmax '+str(self.get_parameter("max_opt_step"))+' '
                           +str(self.get_parameter('max_opt_line'))+'\n')
            file.write('xtol '+str(self.get_parameter('opt_conv_thsld'))+'\n')
            file.write('stepmax '+str(self.get_parameter("max_opt_step_len"))+'\n')
            if self.get_parameter('optimiser') == 'Z-Matrix':
                file.write('value '+str(self.get_parameter('opt_value'))+'\n')

        if task == MENU_ENER:
            if postscf_method == 'MCSCF':
                file.write('mcscf\n')
                file.write('orbital\n')
                file.write('<specify your reference configuration here>\n')
                file.write('end\n')

        if guess_method == "Compute":
            file.write('vectors '+str(self.get_parameter("guess_comp"))+'\n')
        elif guess_method == "Dumpfile":
            if (scf_method == "RHF" or scf_method == "DFT" or 
                scf_method == "Direct RHF" or scf_method == "Direct DFT"):
                file.write('vectors '+str(self.get_parameter("guess_sect1"))+'\n')
            else:
                file.write('vectors '+str(self.get_parameter("guess_sect1"))+' '+
                           str(self.get_parameter("guess_sect2"))+'\n')
                
        elif guess_method == "GETQ":
            guess_lfn = 'ed14' #just use ed14 for now
            guess_blk1 = self.get_parameter("getq_block1")
            guess_blk2 = self.get_parameter("getq_block2")
            guess_sect1 = self.get_parameter("getq_sect1")
            guess_sect2 = self.get_parameter("getq_sect2")
            if (scf_method == "RHF" or scf_method == "DFT" or 
                scf_method == "Direct RHF" or scf_method == "Direct DFT"):
                file.write('vectors getq '+str(guess_lfn)+' '+str(guess_blk1)+' '+str(guess_sect1)+'\n')
            else:
                file.write('vectors getq '+str(guess_lfn)+' '+str(guess_blk1)+' '+str(guess_sect1)+' '+
                           str(guess_lfn)+' '+str(guess_blk2)+' '+str(guess_sect2)+'\n')
                

        if task == MENU_ENER:
            if postscf_method == 'MRDCI':
                file.write('mrdci direct\n')
            elif postscf_method == 'CCSD':
                file.write('ccsd\n')
            elif postscf_method == 'CCSD(T)':
                file.write('ccsd(t)\n')

        if self.get_parameter('ed3_keep'):
            if (scf_method == "RHF" or scf_method == "DFT" or 
                scf_method == "Direct RHF" or scf_method == "Direct DFT"):
                file.write('enter '+str(self.get_parameter('enter_sect1'))+'\n')
            else:
                file.write('enter '+str(self.get_parameter('enter_sect1'))+' '
                           +str(self.get_parameter('enter_sect2'))+'\n')
        else:
            file.write('enter\n')

        #
        # Analysis Options
        #

        #
        # Plot (graphics) options
        #
        spin = self.get_parameter("spin")
        uhf = (scftype == "uhf")
        rohf = (spin != 1 and not uhf)

        count = mol.get_nuclear_charges()
        charge = self.get_parameter("charge")
        count = count - int(charge)

        if uhf:
            count = count - (spin-1)
            homob = (count+1)/2
            lumob = homob+1
            homoa = homob + (spin-1)
            lumoa = homoa + 1
        else:
            count = count - (spin-1)
            homo = (count+1)/2 + (spin-1)
            lumo = homo+1


        alpha_props = []; beta_props = []
        alpha_titles = {}; beta_titles = {}
        alpha_sections = {}; beta_sections = {}
        alpha_punch = []; beta_punch = []

        self.next_section = 100

        if self.get_parameter("ana_chargeden"):
            alpha_props.append('dens')
            alpha_sections['dens'] = self.get_next_section()
            if uhf:
                alpha_titles['dens'] = "Charge Density (alpha)"
                beta_props.append('dens')
                beta_titles['dens'] = "Charge Density (beta)"
                beta_props.append('totdens')
                beta_sections['dens'] = self.get_next_section()
                beta_titles['totdens'] = "Total Charge Density"
                beta_sections['totdens'] = self.get_next_section()
                beta_punch.append(beta_sections['totdens'])                
            else:
                alpha_titles['dens'] = "Charge Density"
                alpha_punch.append(alpha_sections['dens'])

        if self.get_parameter("ana_spinden"):
            if uhf:
                if not self.get_parameter("ana_chargeden"):
                    alpha_props.append('dens')
                    alpha_titles['dens'] = "Charge Density (alpha)"
                    alpha_sections['dens'] = self.get_next_section()
                    beta_props.append('dens')
                    beta_titles['dens'] = "Charge Density (beta)"
                    beta_sections['dens'] = self.get_next_section()
                beta_props.append('spindens')
                beta_titles['spindens'] = "Spin Density"
                beta_sections['spindens'] = self.get_next_section()
                beta_punch.append(beta_sections['spindens'])
            elif rohf:
                self.warn("spin density not implemented for rohf yet")
            else:
                self.warn("cant compute spin density for closed shell system")
                

        if self.get_parameter("ana_chargedengrad"):
            alpha_props.append('grad dens')
            alpha_sections['grad dens'] = self.get_next_section()
            if uhf:
                alpha_titles['grad dens'] = "Grad Charge Density (alpha)"
                beta_titles['grad dens'] = "Grad Charge Density (beta)"
                beta_props.append('grad dens')
                beta_sections['grad dens'] = self.get_next_section()
                beta_props.append('totgraddens')
                beta_titles['totgraddens'] = "Grad Charge Density (total)"
                beta_sections['totgraddens'] = self.get_next_section()
                beta_punch.append(beta_sections['totgraddens'])
            else:
                alpha_titles['grad dens'] = "Grad Charge Density"
                alpha_punch.append(alpha_sections['grad dens'])

        if self.get_parameter("ana_potential"):
            alpha_props.append('pote')
            alpha_sections['pote'] = self.get_next_section()
            if uhf:
                alpha_titles['pote'] = "Potential (alpha)"
                beta_titles['pote'] = "Potential (beta)"
                beta_props.append('pote')
                beta_props.append('totpote')
                beta_sections['pote'] = self.get_next_section()
                beta_titles['totpote'] = "Total Potential"
                beta_sections['totpote'] = self.get_next_section()
                beta_punch.append(beta_sections['totpote'])
            else:
                alpha_titles['pote'] = "Potential"
                alpha_punch.append(alpha_sections['pote'])                

        if self.get_parameter("ana_diffden"):
            alpha_props.append('atom')
            alpha_sections['atom'] = self.get_next_section()
            if uhf:
                # Not sure of atom difference density works for UHF.....
                alpha_titles['atom'] = "Atom Difference Density (alpha)"
                beta_props.append('atom')
                beta_sections['atom'] = self.get_next_section()
                beta_titles['atom'] = "Atom Difference Density (beta)"
                beta_props.append('totatom')
                beta_titles['totatom'] = "Total Atom Difference Density"
                beta_sections['totatom'] = self.get_next_section()
                beta_punch.append(beta_sections['totatom'])
            else:
                alpha_titles['atom'] = "Atom Difference Density"
                alpha_punch.append(alpha_sections['atom'])                

        for n in range(0,6):
            txt = "ana_homolumo"
            if n != 0:
                txt = txt + str(n)
            if self.get_parameter(txt):

                if n == 0:
                    txt3 = "HOMO"
                    txt4 = "LUMO"
                else:
                    txt3 = "HOMO-"+str(n)
                    txt4 = "LUMO+"+str(n)

                if uhf:
                    txt1 = 'mo '+str(homoa-n)
                    alpha_props.append(txt1)
                    alpha_sections[txt1] = self.get_next_section()

                    txt2 = 'mo '+str(lumoa+n)
                    alpha_props.append(txt2)
                    alpha_sections[txt2] = self.get_next_section()

                    alpha_titles[txt1] = txt3 +' (alpha)' + ' [MO '+str(homoa-n)+']'
                    alpha_titles[txt2] = txt4 +' (alpha)' + ' [MO '+str(lumoa+n)+']'

                    alpha_punch.append(alpha_sections[txt1])
                    alpha_punch.append(alpha_sections[txt2])

                    txt1 = 'mo '+str(homob-n)
                    beta_props.append(txt1)
                    beta_titles[txt1] = txt3 +' (beta)'  + ' [MO '+str(homob-n)+']'
                    beta_sections[txt1] = self.get_next_section()

                    txt2 = 'mo '+str(lumob+n)
                    beta_props.append(txt2)
                    beta_titles[txt2] = txt4 +' (beta)' ' [MO '+str(lumob+n)+']'
                    beta_sections[txt2] = self.get_next_section()

                    beta_punch.append(beta_sections[txt1])
                    beta_punch.append(beta_sections[txt2])

                else:

                    txt1 = 'mo '+str(homo-n)
                    alpha_props.append(txt1)
                    alpha_sections[txt1] = self.get_next_section()
                    txt2 = 'mo '+str(lumo+n)
                    alpha_props.append(txt2)
                    alpha_sections[txt2] = self.get_next_section()
                    alpha_punch.append(alpha_sections[txt1])
                    alpha_punch.append(alpha_sections[txt2])
                    alpha_titles[txt1] = txt3 + ' [MO '+str(homo-n)+']'
                    alpha_titles[txt2] = txt4 + ' [MO '+str(lumo+n)+']'

        for orb in self.get_parameter('ana_orbitals'):
            txt1 = 'mo '+str(orb)
            alpha_props.append(txt1)
            alpha_sections[txt1] = self.get_next_section()
            alpha_punch.append(alpha_sections[txt1])
            if uhf:
                alpha_titles[txt1] = "MO "+str(orb)+' (alpha)'
                beta_props.append(txt1)
                beta_titles[txt1] = "MO "+str(orb)+' (beta)'
                beta_sections[txt1] = self.get_next_section()
                beta_punch.append(beta_sections[txt1])
            else:
                alpha_titles[txt1] = "MO "+str(orb)
                    
        if uhf and len(beta_props):
            spins = ['alpha','beta']
        elif len(alpha_props):
            spins = ['alpha']
        else:
            spins = []
                
        for spin in spins:

            file.write('runtype analysis\n')

            if spin == 'alpha':
                props = alpha_props
                sections = alpha_sections
                titles = alpha_titles
                punch = alpha_punch
            else:
                props = beta_props
                sections = beta_sections
                titles = beta_titles
                punch = beta_punch                

            # Punchfile output
            #file.write('nosym\n')
            #file.write('adapt off\n')
            for sect in punch:
                file.write('punch eform grid ' + str(sect)+'\n')

            file.write('graphics\n')
            file.write('gdef\n')
            grid = self.get_parameter('grid')

            if not self.field_sized:
                # use automatic size unless explicitly edited
                # but dont set flag to ensure resizing will happen
                # each time
                self.fit_grid_to_mol(grid,mol)

            scale = 1.0 / 0.529177
            if len(grid.dim) == 3:
                file.write('type 3d\n')
                file.write('points %d %d %d\n' % (grid.dim[0],grid.dim[1],grid.dim[2]))
                file.write('size %f %f %f\n' % (scale*grid.axis[0].length(),
                                                scale*grid.axis[1].length(),
                                                scale*grid.axis[2].length()))
                file.write('orig %f %f %f\n' % (scale*grid.origin[0],
                                                scale*grid.origin[1],
                                                scale*grid.origin[2]))
                v = grid.axis[0]
                file.write('x %f %f %f\n' % (scale*v[0],
                                             scale*v[1],
                                             scale*v[2]))
                v = grid.axis[1]
                file.write('y %f %f %f\n'% (scale*v[0],
                                            scale*v[1],
                                            scale*v[2]))
            elif len(grid.dim) == 2:
                file.write('type 2d\n')
                file.write('points %d %d\n' % (grid.dim[0],grid.dim[1]))
                file.write('size %f %f \n' %  (scale*grid.axis[0].length(),
                                               scale*grid.axis[1].length()))
                file.write('orig %f %f %f\n' % (scale*grid.origin[0],
                                                scale*grid.origin[1],
                                                scale*grid.origin[2]))
                v = grid.axis[0]
                file.write('x %f %f %f\n' % (scale*v[0],scale*v[1],scale*v[2]))
                v = grid.axis[1]
                file.write('y %f %f %f\n' % (scale*v[0],scale*v[1],scale*v[2]))
            else:
                file.write('type 1d\n')
                file.write('points %d\n' % (grid.dim[0],))
                file.write('size %f \n' % (scale*grid.axis[0].length()))
                file.write('size %f %f %f\n' % (grid.dim[0],grid.dim[1],grid.dim[2]))
                file.write('orig %f %f %f\n' % (scale*grid.origin[0],
                                                scale*grid.origin[1],
                                                scale*grid.origin[2]))
                v = grid.axis[0]
                file.write('x %f %f %f\n' % (scale*v[0],scale*v[1],scale*v[2]))

            for prop in props:
                # Load beta component of property for linear combinations (UHF only)
                if prop == 'spindens' or prop == 'totdens':
                    file.write('restore data ed3 1 ' + str(beta_sections['dens']) + '\n')
                elif prop == 'totgraddens':
                    file.write('restore data ed3 1 ' + str(beta_sections['grad dens']) + '\n')
                elif prop == 'totpote':
                    file.write('restore data ed3 1 ' + str(beta_sections['pote']) + '\n')
                elif prop == 'totatom':
                    file.write('restore data ed3 1 ' + str(beta_sections['atom']) + '\n')

                file.write('calc\n')
                # Build linear combinations (UHF only) or else pass
                # the prop string through to GAMESS-UK
                if prop == 'spindens':
                    file.write('type comb ' + str(alpha_sections['dens']) + ' -1.0\n')
                elif prop == 'totdens':
                    file.write('type comb ' + str(alpha_sections['dens']) + ' 1.0\n')
                elif prop == 'totgraddens':
                    file.write('type comb ' + str(alpha_sections['grad dens']) + ' 1.0\n')
                elif prop == 'totpote':
                    file.write('type comb ' + str(alpha_sections['pote']) + ' 1.0\n')
                elif prop == 'totatom':
                    file.write('type comb ' + str(alpha_sections['atom']) + ' 1.0\n')
                else:
                    file.write('type ' + prop + '\n')
                file.write('title\n')
                file.write(titles[prop]+'\n')
                if sections.has_key(prop):
                    file.write('section '+str(sections[prop])+'\n')

            # Select vectors to analyse
            if spin == 'alpha':
                if uhf:
                    file.write('vectors 2\n')
                    file.write('enter 2\n')
                elif rohf:
                    # pick canonicalised set
                    file.write('vectors 5\n')
                    file.write('enter 5\n')
                else:
                    file.write('vectors 1\n')
                    file.write('enter 1\n')
            else:
                file.write('vectors 3\n')
                file.write('enter 3\n')
        #
        # Frequencies
        #

        if self.get_parameter("ana_frequencies"):
            # Need to re-specify if not using symmetry as these are secondary jobs
            if not self.get_parameter('symmetry'):
                file.write('nosym\n')
                file.write('adapt off\n')
            file.write('runtype force\n')
            file.write('punch normal vibr\n')
            file.write('enter 1\n')

        if self.get_parameter("ana_hessian"):
            # Need to re-specify if not using symmetry as these are secondary jobs
            if not self.get_parameter('symmetry'):
                file.write('nosym\n')
                file.write('adapt off\n')
            file.write('runtype hessian\n')
            file.write('punch normal vibr\n')
            file.write('enter 1\n')

        # Input writing finishes here
        file.close()
        return 0

    def get_next_section(self):
        # return the next section to use
        if self.next_section:
            self.next_section = self.next_section + 1
            return self.next_section
        else:
            print "No next_section defined in gamessuk.py.__WriteInput!\n"
            return 0

    def _write_basis(self,file):

        basis = self.get_parameter("basisdirectives")
        if basis != "":
            file.write(basis)
        else:
            basis = self.get_parameter("basis")
            if basis:
                # Use the result of the basis manager
                # for more details see the basis manager module
                file.write('basis\n')
                for entry in basis:
                    (ass_type, tag, b) = entry
                    print 'entry', ass_type, tag, b
                    if ass_type == 'TYPE.KEY':
                        #If b contains 2 fields, need to place element symbol between the two:
                        basis_keyword=string.split(b)
                        length=len(basis_keyword)
                        if (length>1): # > one keyword
                            file.write('%s %s %s\n' %(basis_keyword[0],tag,basis_keyword[1]))
                        else:
                            file.write('%s %s\n' % (basis_keyword[0], tag))#only 1 keyword
                    if ass_type == 'TYPE.EXPL':
                        b.list()
                        for shell in b.shells:
                            file.write('%s %s\n' % (shell.type, tag))
                            for p in shell.expansion:
                                print 'expansion',p,len(p)
                                if len(p) == 2:
                                    file.write( '%12.8f %8.4f\n' % (p[1],p[0]))
                                elif len(p) == 3:

                                    file.write( '%12.8f %8.4f %8.4f\n' % (p[1],p[0],p[2]))
                                else:
                                    print 'ELSE'
                file.write('end\n')

            else:
                # Use the default
                basis = self.get_parameter("default_basis")
                file.write('basis ' + basis+'\n')

    def _write_ecp(self,file):
        
        ecp = self.get_parameter("ECP")
        if ecp:
            file.write('pseudo ecp\n')
            for entry in ecp:
                print 'entry:',entry
                (ass_type, tag, b) = entry
                print 'entry', ass_type, tag, b
                if ass_type == 'TYPE.KEY':
                    #The form of the input for GAMESS is: 'el sym' ecp 'el tag'
                    #so just strip any numbers off 'el tag' to get the symbol
                    basis_keyword=string.split(b)
                    trans = string.maketrans('a','a')
                    el_sym = string.translate(tag,trans,string.digits)
                    file.write('%s %s %s\n' %(el_sym,basis_keyword[1],tag))
                if ass_type == 'TYPE.EXPL':
                    file.write('cards %s\n' % (tag))
                    file.write('%s %s\n' % (b.lmax, b.ncore))
                    b.list()
                    for shell in b.shells:
                        file.write('%d \n' % (len(shell.expansion)))
                        for p in shell.expansion:
                            print 'expansion',p,len(p)
                            file.write( '%d %8.4f %8.4f\n' % (p[0],p[1],p[2]))
                        else:
                            print 'ELSE'

    def scan(self):
        """Extract and Store results from a punchfile"""
        file = tkFileDialog.askopenfilename(filetypes=[("Punch File","*.pun"),("All Files","*.*")])
        job_name = self.get_parameter("job_name")
        self.__ReadPunch(file)
        # reflect changes in the visible page
        if self.editor():
            self.editor().UpdateOpenPage()

    def __ReadPunch(self,file):
        """Read the GAMESS-UK punchfile and store all resulting objects
        """
        p = PunchReader()
        p.scan(file)

        if not p.title:
            p.title = self.get_title()
        if p.title == "untitled":
            p.title = self.get_input("mol_name")

        self.results = []

        # construct the results list for visualisation

        structure_loaded=0
        for o in p.objects:

            # take the last field of the class specification
            t1 = string.split(str(o.__class__),'.')
            myclass = t1[len(t1)-1]

            if myclass == 'VibFreq' :
                # create a vibration visualiser
                self.results.append(o)

            if myclass == 'VibFreqSet' :
                # create a vibration set visualiser
                self.results.append(o)

            elif myclass == 'Indexed' or myclass == 'Zmatrix':
                # will need to organise together with other results
                # assume overwrite for now
                ###name = self.get_input("mol_name")
                ###print 'set_input executed',o
                ###self.set_input("mol_obj",o)
                #
                #PS keep all elements of old structure
                #
                oldo = self.get_input("mol_obj")
                copycontents(oldo,o)

                #o.list()
                #tt = self.get_input("mol_obj")
                #tt.list()

                structure_loaded=1
                # Used by visualisers
                #o.title = name
                #o.list()

            elif myclass == 'Brick':
                self.results.append(o)

            elif myclass == 'Field':
                self.results.append(o)

        return structure_loaded


homolumoa = 0

class GAMESSUKCalcEd(QMCalcEd):

    def __init__(self,root,calc,graph,**kw):
        apply(QMCalcEd.__init__, (self,root,calc,graph), kw)

        # Associate helpfile with widget
        viewer.help.sethelp(self,'MoleculeTab')
        
        self.tasks = [MENU_ENER, MENU_GRAD, MENU_OPT]
            #"numerical force constants",
            #"analytical force constants",
            #"polarisability",
            #"hyper polarisability",
            #"magnetisability",
            #"Raman intensities",
            #"infrared intensities",
            #"UV/Vis intensities"]
        self.theories[MENU_ENER] = [
             "RHF", "UHF", "MP2", "B3LYP", "UB3LYP", 
             "BLYP", "UBLYP", "SVWN", "USVWN", 
             "HCTH", "UHCTH", "FT97", "UFT97"]
        self.theories[MENU_GRAD] = [
             "RHF", "UHF", "MP2", "B3LYP", "UB3LYP", 
             "BLYP", "UBLYP", "SVWN", "USVWN", 
             "HCTH", "UHCTH", "FT97", "UFT97"]
        self.theories[MENU_OPT] = [
             "RHF", "UHF", "MP2", "B3LYP", "UB3LYP", 
             "BLYP", "UBLYP", "SVWN", "USVWN", 
             "HCTH", "UHCTH", "FT97", "UFT97"]
        self.scf_methods = {}

##         self.scf_methods[MENU_ENER] = [
##              "RHF", "UHF", "GVB", "DFT", "UDFT" ,
##              "Direct RHF", "Direct UHF", "Direct GVB", "Direct DFT", "Direct UDFT"]
##         self.scf_methods[MENU_GRAD] = [
##              "RHF", "UHF", "GVB", "DFT", "UDFT" ,
##              "Direct RHF", "Direct UHF", "Direct GVB", "Direct DFT", "Direct UDFT"]
##         self.scf_methods[MENU_OPT] = [
##              "RHF", "UHF", "GVB", "DFT", "UDFT" ,
##              "Direct RHF", "Direct UHF", "Direct GVB", "Direct DFT", "Direct UDFT"]

        self.scf_methods[MENU_ENER] = [
              "RHF", "UHF", "DFT", "UDFT" ,
              "Direct RHF", "Direct UHF", "Direct DFT", "Direct UDFT"]
        self.scf_methods[MENU_GRAD] = [
              "RHF", "UHF", "DFT", "UDFT" ,
              "Direct RHF", "Direct UHF", "Direct DFT", "Direct UDFT"]
        self.scf_methods[MENU_OPT] = [
              "RHF", "UHF", "DFT", "UDFT" ,
              "Direct RHF", "Direct UHF",  "Direct DFT", "Direct UDFT"]


        #DFT options
        self.dft_functionals = [
             "SVWN", "BLYP", "B3LYP", "B97", "HCTH", "FT97"]
        self.dft_grids = ["low", "medium", "high", "veryhigh"]
        self.dft_radialgrids = ["default","Euler-MacLaurin","Mura-Knowles"]
        self.dft_angulargrids = ["default","Lebedev-Laikov","Gauss-Legendre"]
        # This is the full list of possible points, they are not supported in the
        #standard version of gamess, so not needed here.
        #self.dft_lebedevpoints =[6,14,26,38,50,74,86,110,146,170,194,230,266,
        #                         302,350,434,590,770,974,1202,1454,1730,2030,
        #                         2354,2702,3074,3470,3890,4334,4802,5294,5810]
        self.dft_lebedevpoints =[6,14,26,38,50,74,86,110,146,170,194,230,266,
                                 302,350,434,590,770,974,1202]
        self.dft_weights = ["Becke","MHL","SSF","MHL4SSF","MHL8SSF"]
        self.dft_jbas = ["A1DGAUSS","A2DGAUSS","DEMON","AHLRICHS"]
        
        self.postscf_methods = {}
        self.postscf_methods[MENU_ENER] = [
             "None", "MCSCF", "MP2", "MP3", 
             "CCSD", "CCSD(T)", "Direct CI", "MRDCI",
             "Direct MP2" ]
        self.postscf_methods[MENU_GRAD] = [
             "None", "MCSCF", "MP2", "MP3", 
             "Direct MP2"]
        self.postscf_methods[MENU_OPT] = [
             "None", "MCSCF", "MP2", "MP3",
             "Direct MP2"]
        self.guess_options = ["Compute","Dumpfile","GETQ"]
        self.compute_options = ["atoms","hcore","minguess","extguess","atorb"]
        scf_rhf = ["RHF","B3LYP" ,"BLYP" ,"SVWN" ,"HCTH" ,"FT97"]
        scf_uhf = ["UHF","UB3LYP","UBLYP","USVWN","UHCTH","UFT97"]

        self.optcoord_opts = [ "Z-Matrix","Cartesian" ]
        self.optbfgs_opts = ["default","BFGS","BFGSX"]
        self.optrfo_opts = ["on","off"]
        self.submission_policies = [ LOCALHOST,"RMCS", "Nordugrid", "GROWL"]

        self.jobSubmitEd = None
        
        #Create the tools used in the Molecule tab - spin & charge created in QM.
        self.task_tool = SelectOptionTool(self,'task','Task',self.tasks,command=self.__taskupdate)
        self.balloon.bind( self.task_tool.widget, 'Specify the type of calculation to run.' )
        
        #Used to specify task
        self.tasktoolvalue = self.task_tool.widget.getvalue() 

        self.checkspin_widget = Tkinter.Button(self.interior(),
                                             text = 'Check Spin',
                                             command = self.__CheckSpin)
        self.balloon.bind( self.checkspin_widget, 'Check if the spin is consistent for the molecule' )
        
        self.symmetry_tool = BooleanTool(self,'symmetry','Use Symmetry')
        self.balloon.bind( self.symmetry_tool.widget, 'Turn on the use of symmetry during the calculation' )

        mol_obj = self.calc.get_input('mol_obj')

        # need to propagate the default basis back

        self.basis_manager = self.calc.basis_manager
        
        self.basis_tool = BasisTool(self,'basis','ECP','default_basis',
                                    molecule=mol_obj,basis_manager=self.basis_manager)

        #Create the tools used in the Theory tab
        #self.guess_tool = GamessGuessTool(self,self.__guesscommand)
        self.guessoption_tool = SelectOptionTool(self,'guess_method','Vectors',self.guess_options,
                                                 self.__guesstype)
        self.balloon.bind( self.guessoption_tool.widget, 'Determine how the initial vectors for the guess are computed' )
        self.guessatoms_tool = SelectOptionTool(self,'guess_comp',None,self.compute_options)
        self.guesssection1_tool = IntegerTool(self,'guess_sect1','Section a',0)
        self.guesssection2_tool = IntegerTool(self,'guess_sect2','Section b',0)
        self.guessgetqblock1_tool = IntegerTool(self,'getq_block1','File Block a',0)
        self.guessgetqblock2_tool = IntegerTool(self,'getq_block2','File Block b',0)
        self.guessgetqsection1_tool = IntegerTool(self,'getq_sect1','File Section a',0)
        self.guessgetqsection2_tool = IntegerTool(self,'getq_sect2','File Section b',0)
        
        self.scfmethod_tool = SelectOptionTool(self,'scf_method',
                                               'SCF Method',
                                               self.scf_methods[self.tasktoolvalue],
                                               self.__scfmethod)
        self.scfmaxcycles_tool = IntegerTool(self,'scf_maxcyc','Max. Cycles',1)
        self.balloon.bind( self.scfmaxcycles_tool.widget, 'Maximum permitted number of SCF cycles' )
        self.scfthreshold_tool = IntegerTool(self,'scf_threshold','Threshold',3)
        self.balloon.bind( self.scfthreshold_tool.widget, 'Consider the SCF converged when Energy change is less than 10x(-n) this number' )

        self.scfbypass_tool = BooleanTool(self,'scf_bypass', 'Bypass SCF')
        self.balloon.bind( self.scfbypass_tool.widget, 'Eschew SCF calculation. Read integrals and vectors from dumpfile instead' )

        self.scflevelinit_tool = FloatTool(self,'scf_level_init','Initial Levelshifter Value',0.0)
        self.scflevelit_tool = IntegerTool(self,'scf_level_it','Cycle to change on',1)
        self.scflevelfinal_tool = FloatTool(self,'scf_level_final','Final Levelshifter Value',0.0)
        

        self.postscfmethod_tool = SelectOptionTool(self,'postscf_method',
                                                   'Method',
                                                   self.postscf_methods[self.tasktoolvalue])


        #Create the tools for the DFT tab
        self.dftfunctional_tool = SelectOptionTool(self,'dft_functional','Functional',self.dft_functionals)
        self.dftaccuracy_tool = SelectOptionTool(self,'dft_grid','Grid setting',self.dft_grids)
        self.balloon.bind( self.dftaccuracy_tool.widget, 'Specify a quadrature grid designed to achieve a particular accuracy' )
        self.dftweightscheme_tool = SelectOptionTool(self,'dft_weights',
                                                     'DFT weighting scheme',
                                                     self.dft_weights)

        self.dftradial_tool = MenuCounterTool(self,
                                              'dft_radialgrid',
                                             'Radial Grid',
                                             self.dft_radialgrids,
                                             'dft_radialgridpoints',
                                             'Number of points',
                                             command = self.__dftradialgridpoints
                                             )
        self.radialgrid = self.dftradial_tool.firstmenu.getvalue()
        
        self.dftangular_tool = MenuCounterMenuTool(self,
                                                   'dft_angulargrid',
                                                   'Angular Grid',
                                                   self.dft_angulargrids,
                                                   'dft_angulargridpoints',
                                                   'Number of points',
                                                   'dft_angulargridpoints',
                                                   'Number of points',
                                                   self.dft_lebedevpoints,
                                                   command = self.__dftangulargridpoints
                                                   )
        self.angulargrid = self.dftangular_tool.firstmenu.getvalue()

        self.dftjfit_tool = BooleanTool(self,'dft_jfit','Use Coulomb Fitting',self.__dftjbasselect)
        self.balloon.bind( self.dftjfit_tool.widget, 'Evaluate the Coulomb energy with an auxilary basis set' )
        self.dftjbas_tool = SelectOptionTool(self,'dft_jbas','Fitting Basis',self.dft_jbas)
        self.balloon.bind( self.dftjbas_tool.widget, 'Select the auxilary fitting basis' )
        self.dftschwarz_tool = IntegerTool(self,'dft_schwarz','Schwarz cutoff')
        self.balloon.bind( self.dftschwarz_tool.widget, 'Reduce the number of 3e integrals by setting Schwarz tolerance to 10x-(n)' )

        #Create the tools used in the Properties tab
        self.homolumo_tool = BooleanTool(self, 'ana_homolumo', 'HOMO/LUMO')
        self.homolumo1_tool = BooleanTool(self, 'ana_homolumo1', 'HOMO1/LUMO1')
        self.homolumo2_tool = BooleanTool(self, 'ana_homolumo2', 'HOMO2/LUMO2')
        self.homolumo3_tool = BooleanTool(self, 'ana_homolumo3', 'HOMO3/LUMO3')
        self.homolumo4_tool = BooleanTool(self, 'ana_homolumo4', 'HOMO4/LUMO4') 
        self.homolumo5_tool = BooleanTool(self, 'ana_homolumo5', 'HOMO5/LUMO5')
       
        self.chargeden_tool = BooleanTool(self, 'ana_chargeden', 'Charge Density')
        self.balloon.bind ( self.chargeden_tool.widget, 'Calculate the charge density and import the results back for display' )
        self.diffden_tool = BooleanTool(self, 'ana_diffden', 'Difference Density')
        self.potential_tool = BooleanTool(self, 'ana_potential', 'Potential')
        self.balloon.bind ( self.potential_tool.widget, 'Calculate the electrostatic potential and import the results back for display' )                
        self.chargedengrad_tool = BooleanTool(self, 'ana_chargedengrad', 'Gradient Density')
        self.spinden_tool = BooleanTool(self, 'ana_spinden', 'Spin Density')
        self.frequencies_tool = BooleanTool(self, 'ana_frequencies', 'Finite Difference')
        self.balloon.bind( self.frequencies_tool.widget, 'Calculate force constants numerically' )
        self.hessian_tool = BooleanTool(self, 'ana_hessian', "Analytic")
        self.balloon.bind( self.hessian_tool.widget, 'Calculate the force constants analytically' )

        #Create the tools used in the Optimisation tab
        self.optcoords_tool = SelectOptionTool(self,'optimiser', 'Opt. Coords',
                                               self.optcoord_opts, self.__selectcoords)
        self.find_ts_tool = BooleanTool(self,"find_ts","Locate Transition State",self.__findts)
 #       self.optmethod_tool = SelectOptionTool(self,'optimiser_method','Method',self.optmethodopts)

        self.optmaxcyc1_tool = IntegerTool(self,'max_opt_step','Energy evaluations',0)
        self.optmaxcyc2_tool = IntegerTool(self,'max_opt_line','Line searches',0)
        self.optxtol_tool = FloatTool(self,'opt_conv_thsld','Convergence Thresh.',0.0)        
        self.optstepmax_tool = FloatTool(self,'max_opt_step_len','Max. Step size',0.0)        
        self.optvalue_tool = FloatTool(self,'opt_value','Turning Point Accuracy',0.0)

        self.optjorg_tool = BooleanTool(self,'opt_jorgensen','Use Jorgensen-Simons Algorithm',
                                        self.__optjorgensen)
        self.optpowell_tool = BooleanTool(self,'opt_powell','Use Powell Hessian update')
        self.optbfgs_tool = SelectOptionTool(self,'opt_hess_update', 'Hessian Update Procedure',
                                             self.optbfgs_opts)
        self.optminhess_tool = FloatTool(self,'opt_min_hess','Min. Hessian Eigenvalue')
        self.optmaxhess_tool = FloatTool(self,'opt_max_hess','Max. Hessian Eigenvalue')
        self.optrfo_tool = MenuAndBooleanTool(self,'opt_rfo','opt_rfomode',
                                              'Use Rational Function Optimisation',
                                              'RFO Mode',self.optrfo_opts)

        #Create the tools used for the Job tab
        self.jobname_tool = TextFieldTool(self,'job_name','Job Name')
        self.balloon.bind( self.jobname_tool.widget, 'Specify the prefix for all output files' ) 
        self.workingdirectory_tool = ChangeDirectoryTool(self,'directory','Working Directory')
        self.balloon.bind( self.workingdirectory_tool.widget, 'Specify where the calculation will be run from' )
        self.submission_tool = SelectOptionTool(self,'submission','Job Submission',
                                                self.submission_policies,
                                                self.change_submission_policy)

        #Create the tools used in the Restart Group
        self.ed0keep_tool = BooleanTool(self, 'ed0_keep', 'specify',
                                        command=lambda s=self: s.__keepfile('ed0'))
        self.ed0path_tool = ChangeDirectoryTool(self,'ed0_path','')
        self.ed2keep_tool = BooleanTool(self, 'ed2_keep', 'keep',
                                        command=lambda s= self: s.__keepfile('ed2'))
        self.balloon.bind( self.ed2keep_tool.widget, 'Save the integral file' )
        self.ed2name_tool = BooleanTool (self, 'ed2_specify','specify ',
                                         command=lambda s=self: s.__keepfile('ed2'))
        self.balloon.bind( self.ed2name_tool.widget, 'Toggle saving with the default name or a user-specified one' )        
        self.ed2path_tool = FileTool(self,'ed2_path','',
                                      filetypes=[('Mainfiles','*.ed2'), ('All files','*.*')])
        self.ed3keep_tool = BooleanTool(self, 'ed3_keep', 'keep',
                                        command=lambda s = self: s.__keepfile('ed3'))
        self.balloon.bind( self.ed3keep_tool.widget, 'Save the dump file - required to restart calculations' )
        self.ed3name_tool = BooleanTool (self, 'ed3_specify','specify ',
                                         command=lambda s=self: s.__keepfile('ed3'))
        self.balloon.bind( self.ed3name_tool.widget, 'Toggle saving with the default name or a user-specified one' )                
        self.ed3path_tool = FileTool(self,'ed3_path','',
                                     filetypes=[('Dumpfiles','*.ed3'), ('All files','*.*')])
        self.ed7keep_tool = BooleanTool(self, 'ed7_keep', 'keep',
                                        command=lambda s = self: s.__keepfile('ed7'))
        self.balloon.bind( self.ed7keep_tool.widget, 'Save the scratch file' )        
        self.ed7name_tool = BooleanTool (self, 'ed7_specify','specify ',
                                         command=lambda s=self: s.__keepfile('ed7'))
        self.balloon.bind( self.ed7name_tool.widget, 'Toggle saving with the default name or a user-specified one' )                        
        self.ed7path_tool = FileTool(self,'ed7_path','',
                                      filetypes=[('Tempfiles','*.ed7'), ('All files','*.*')])
        self.ed14keep_tool = BooleanTool(self, 'ed14_keep', 'specify',
                                        command=lambda s=self: s.__keepfile('ed14'))
        self.balloon.bind( self.ed14keep_tool.widget, 'Specify a \'foreign\' dumpfile for a restart calculation' )        
        self.ed14path_tool = FileTool(self,'ed14_path','',
                                      filetypes=[('Dumpfiles','*.ed3'), ('All files','*.*')],
                                      action="open")

        self.LayoutToolsTk()

        self.__initialisetools()
        
        self.menu.addmenuitem('View','command',
                     'View a summary of results',
                     command = lambda s=self: s.summarise_results(),
                     label = 'Results Summary')
        # flag to check if we already have a summary editor open
        self.summaryeditor=None


    def __initialisetools(self):
        """Initialise any tools and variables that effect the defaults that are displayed.
        """
        self.task_tool.widget.invoke(self.calc.get_parameter('task'))
        self.scfmethod_tool.widget.invoke(self.calc.get_parameter('scf_method'))
        self.guessoption_tool.widget.invoke(self.calc.get_parameter('guess_method'))
        job_name = str(self.calc.get_name())
        self.calc.set_parameter('job_name',job_name)
        self.jobname_tool.UpdateWidget()
        cwd = os.getcwd()
        self.calc.set_parameter('directory',str(cwd))
        self.workingdirectory_tool.UpdateWidget()
        self.__getenvironment()
        self.ed0path_tool.UpdateWidget()
 
    def __taskupdate(self,task):
        """Update the SCF and post-SCF methods for the task that has been selected
           and hide the optimisation tab
        """
        self.scfmethod_tool.SetItems(self.scf_methods[task])
        self.postscfmethod_tool.SetItems(self.postscf_methods[task])
        if task != 'Geometry Optimisation':
            self.notebook.tab('Optimisation').configure(state="disabled")
        else:
            self.notebook.tab('Optimisation').configure(state="active")

    def __CheckSpin(self):
        for tool in self.tools:
            tool.ReadWidget()
        self.calc.CheckSpin()

    def __scfmethod(self,scf):
        """Configure all widgets and variables that depend on the SCF type.
        """
        self.scfmethod_tool.ReadWidget()
        if (scf == 'DFT') or (scf == 'UDFT') or (scf == 'Direct DFT') or (scf == 'Direct UDFT'):
            self.notebook.tab('DFT').configure(state="active")
        else:
            self.notebook.tab('DFT').configure(state="disabled")
            
        # REM the default 'enter' and 'vectors' sections are configured in the __guesstype
        #  method as this is always run after the __scfmethod is invoked
        #guess = self.calc.get_parameter("guess_method")
        self.__guesstype("")

    def __guesstype(self,value):
        """Display the relevant tools depending on where we are going to be getting the
           vectors from for this calculation.
        """
        # 1st 3 lines a bit daft but need in case we called from __scfmethod
        self.guessoption_tool.ReadWidget() 
        guess = self.calc.get_parameter('guess_method')
        scf = self.calc.get_parameter('scf_method')
        
        self.guessatoms_tool.Forget()
        self.guesssection1_tool.Forget()
        self.guesssection2_tool.Forget()
        self.guessgetqblock1_tool.Forget()
        self.guessgetqblock2_tool.Forget()
        self.guessgetqsection1_tool.Forget()
        self.guessgetqsection2_tool.Forget()
        
        # configure the default 'enter' and 'vectors' sections
        if (scf == "RHF") or (scf == "DFT") or (scf == "Direct RHF") or (scf == "Direct DFT") :
            #if self.calc.get_parameter("postscf_method") == "MCSCF":
            #    self.calc.set_parameter("enter_sect1","6")
            #    self.calc.set_parameter("enter_sect1","7")
            #else:
            self.calc.set_parameter("enter_sect1","1")
            self.calc.set_parameter("guess_sect1","1")
            self.calc.set_parameter("getq_sect1","1")
        if (scf == "UHF") or (scf == "UDFT") or (scf == "Direct UHF") or (scf == "Direct UDFT") :
            #if self.calc.get_parameter("postscf_method") == "MCSCF":
            #    self.calc.set_parameter("enter_sect1","6")
            #    self.calc.set_parameter("enter_sect1","7")
            #else:
            self.calc.set_parameter("enter_sect1","2")
            self.calc.set_parameter("enter_sect2","3")
            self.calc.set_parameter("guess_sect1","2")
            self.calc.set_parameter("guess_sect2","3")
            self.calc.set_parameter("getq_sect1","2")
            self.calc.set_parameter("getq_sect2","3")
            
        if (scf == "GVB") or (scf == "Direct GVB"):
            #if self.calc.get_parameter("postscf_method") == "MCSCF":
            #    self.calc.set_parameter("enter_sect1","6")
            #    self.calc.set_parameter("enter_sect1","7")
            #else:
            self.calc.set_parameter("enter_sect1","4")
            self.calc.set_parameter("enter_sect2","5")
            self.calc.set_parameter("guess_sect1","4")
            self.calc.set_parameter("guess_sect2","5")
            self.calc.set_parameter("getq_sect1","4")
            self.calc.set_parameter("getq_sect2","5")
             
        if (guess == 'Compute'):
            self.guessatoms_tool.Pack()
        elif (guess == 'Dumpfile'):
            if (scf == "RHF") or (scf == "DFT") or (scf == "Direct RHF") or (scf == "Direct DFT"):  
                self.guesssection1_tool.UpdateWidget()
                self.guesssection1_tool.Pack()
            else:
                self.guesssection1_tool.Pack()
                self.guesssection2_tool.Pack()
                self.guesssection1_tool.UpdateWidget()
                self.guesssection2_tool.UpdateWidget()
        elif (guess == 'GETQ'):
            if (scf == "RHF") or (scf == "DFT") or (scf == "Direct RHF") or (scf == "Direct DFT"):  
                self.guessgetqblock1_tool.UpdateWidget()
                self.guessgetqsection1_tool.UpdateWidget()
                self.guessgetqblock1_tool.Pack()
                self.guessgetqsection1_tool.Pack()
                Pmw.alignlabels([self.guessgetqblock1_tool.widget,
                                 self.guessgetqsection1_tool.widget])
                
            else:
                self.guessgetqblock1_tool.UpdateWidget()
                self.guessgetqsection1_tool.UpdateWidget()
                self.guessgetqblock2_tool.UpdateWidget()
                self.guessgetqsection2_tool.UpdateWidget()
                self.guessgetqblock1_tool.Pack()
                self.guessgetqsection1_tool.Pack()
                self.guessgetqblock2_tool.Pack()
                self.guessgetqsection2_tool.Pack()
                Pmw.alignlabels([self.guessgetqblock1_tool.widget,
                                 self.guessgetqblock2_tool.widget,
                                 self.guessgetqsection1_tool.widget,
                                 self.guessgetqsection2_tool.widget])
                

    def change_submission_policy(self,policy):
        """Configure the frame depending on the policy chosen"""

        if policy == LOCALHOST:
            self.submission_config_button.forget()
        else:
            self.submission_config_button.pack(side='left')

    def configure_jobSubmitEd(self):
        """Fire up the appropriate widget to configure the job depending on
           whether we are using RMCS, Growl, Nordugrid..."""

        try:
            jobSubmitEd = self.get_jobSubmitEd()
        except Exception,e:
            self.Error("Error initialising job submission editor!\n%s" % e)

        jobSubmitEd.show()

                
    def get_jobSubmitEd(self):
        """Return the appropriate jobSubmitEd widget or create one if it doens't exist
           if the manager string is supplied we return the instance of that type of manager
        """

        # Get the appropriate string for the manager
        editor = self.submission_tool.ReadWidget()

        if self.jobSubmitEd:
            #edtype = str(self.jobSubmitEd).split()[0]
            edtype = self.jobSubmitEd.jobtype
            #print "edtype is ",edtype
            if edtype == editor:
                return self.jobSubmitEd
            else:
                # Should ask here first...
                self.jobSubmitEd.destroy()

        # We either didn't have a job editor or we have destroyed the old one
        #print "creating jobSubmitEd"
        if editor == 'RMCS':
            self.jobSubmitEd = RMCSEditor(self.interior(),onkill=self.jobSubmitEd_die,  calc=self.calc)
        elif editor == 'Nordugrid':
            self.jobSubmitEd = NordugridEditor(self.interior(), onkill=self.jobSubmitEd_die, calc=self.calc)
        elif editor == 'GROWL':
            self.jobSubmitEd = GrowlEditor(self.interior(), onkill=self.jobSubmitEd_die, calc=self.calc,
                                           debug=1)
        else:
            raise AttributeError, "gamessuk calced - unrecognised job editor: %s" % editor

        return self.jobSubmitEd

    def jobSubmitEd_die(self):
        """Set the jobSubmitEditor variable to None"""
        self.jobSubmitEd = None
            
    def __dftradialgridpoints(self,choice):
        """Select the number of gridpoints dependant on the radial grid selected
        """
        print "choice is: " + choice
        if (choice == 'Euler-MacLaurin' or choice == 'Mura-Knowles'):
            self.dftradial_tool.ShowCounter()
        else:
            self.dftradial_tool.HideCounter()
       
    def __dftangulargridpoints(self,choice):
        """Select the number of gridpoints dependant on the angular grid selected
        """
        if (choice == 'Gauss-Legendre'):
            self.dftangular_tool.ShowCounter()
            self.dftangular_tool.HideMenu()
        if (choice == 'Lebedev-Laikov'):
            self.dftangular_tool.ShowMenu()
            self.dftangular_tool.HideCounter()
        if (choice == 'default'):
            self.dftangular_tool.HideCounter()
            self.dftangular_tool.HideMenu()

    def __dftjbasselect(self):
        """Configure the tools to be displayed depending on whether we are using
           Coulomb fitting in a DFT calculation.
        """
        self.dftjfit_tool.ReadWidget()

        if self.calc.get_parameter('dft_jfit'):
            self.dftjbas_tool.Pack()
            self.dftschwarz_tool.Pack()
        else:
            self.dftjbas_tool.Forget()
            self.dftschwarz_tool.Forget()
            
    #Optimisation methods are here
    def __selectcoords(self,choice):
        """Display the tools suitable for the coordinate scheme selected
           and with their default values.
        """
        #Read this, the findts and jorgensen widgets to see where we are at:
        self.find_ts_tool.ReadWidget()
        self.optjorg_tool.ReadWidget()
        self.optcoords_tool.ReadWidget()
        
        if (self.calc.get_parameter('optimiser') == 'Cartesian'):
            self.optxtol_tool.UpdateWidget()
            if (self.calc.get_parameter('find_ts')):
                self.Error('Transistion state location requires internal coordinates!\n'
                           +'Make sure the z-matrix for your molecule is suitable.')
                self.calc.set_parameter('find_ts',0)
                #self.find_ts_tool.UpdateWidget()
                #self.__findts()
                return
                
            if (self.calc.get_parameter('opt_jorgensen')):
                self.Error('Use of the Jorgensen-Simons algorithm requires internal coordinates!\n'
                           +'Make sure the z-matrix for your molecule is suitable.')
                #self.calc.set_parameter('opt_jorgensen',0)
                #self.optjorg_tool.UpdateWidget()
                #self.__optjorgensen()
                return
                
            self.optvalue_tool.Forget()
            self.calc.set_parameter('opt_conv_thsld',0.001)

                
        elif (self.calc.get_parameter('optimiser') == 'Z-Matrix'):
            self.calc.set_parameter('opt_value',0.3)
            self.optvalue_tool.UpdateWidget()
            self.optvalue_tool.Pack()
            self.calc.set_parameter('opt_conv_thsld',0.003)
            self.optxtol_tool.UpdateWidget()

    def __findts(self):
        """Configure the optimisation widget with the tools suitable for
           finding a transition state and with their default values.
        """
        self.find_ts_tool.ReadWidget()
        self.optjorg_tool.ReadWidget()
        self.optcoords_tool.ReadWidget()
        
        #Warn if not using internal coordiantes
        if self.calc.get_parameter('find_ts')== 1:
            if self.calc.get_parameter('optimiser') == 'Cartesian':
                self.__selectcoords('Cartesian') #this triggers the warning
                self.calc.set_parameter('optimiser','Z-Matrix')
                self.optcoords_tool.UpdateWidget()
                self.__selectcoords('Z-Matrix')
            if (self.calc.get_parameter('opt_jorgensen')):
                self.__optjorgensen()
                
            self.calc.set_parameter('opt_conv_thsld',0.001)
            self.optxtol_tool.UpdateWidget()
            self.calc.set_parameter('opt_value',0.3)
            self.optvalue_tool.UpdateWidget()

        if self.calc.get_parameter('find_ts')== 0: #update coord and jorg tools accordingly
            self.__selectcoords(self.calc.get_parameter('optimiser'))
            self.__optjorgensen()

    def __optjorgensen(self):
        """If we are undertaking a geometry optimisation using the Jorgensen/Simmons algorithm
           display the tools required for the type of calculation.
        """
        self.find_ts_tool.ReadWidget()
        self.optcoords_tool.ReadWidget()
        self.optjorg_tool.ReadWidget()
        
        opttype = self.calc.get_parameter('find_ts')#type of optimisation
        
        #forget everything unless we need it
        self.optpowell_tool.Forget()
        self.optbfgs_tool.Forget()
        self.optminhess_tool.Forget()
        self.optmaxhess_tool.Forget()
        self.optrfo_tool.Forget()

        if self.calc.get_parameter('opt_jorgensen'):
            if self.calc.get_parameter('optimiser') == 'Cartesian':
                self.__selectcoords('Cartesian') #Trigger the warning
                self.calc.set_parameter('optimiser','Z-Matrix')
                self.optcoords_tool.UpdateWidget()
                self.__selectcoords('Z-Matrix')
                
            if  self.calc.get_parameter('find_ts'):
                self.optpowell_tool.Pack()
            else:
                self.optbfgs_tool.Pack()
                
            self.optminhess_tool.Pack()
            self.optmaxhess_tool.Pack()
            self.optrfo_tool.Pack()


    def __keepfile(self,lfn):
        """If we are saving the file, show the tool to select the file name.
        """
        name = str(self.calc.get_parameter("job_name"))
        dir = str(self.calc.get_parameter("directory"))

        if (lfn =='ed0'):
            self.ed0keep_tool.ReadWidget()
            if (self.calc.get_parameter('ed0_keep')):
                self.ed0path_tool.Pack(side='left')
            else:
                self.ed0path_tool.Forget()
                
        if (lfn =='ed2'):
            self.ed2keep_tool.ReadWidget()
            self.ed2name_tool.ReadWidget()
            if (self.calc.get_parameter('ed2_keep')):
                self.ed2path_tool.Pack(side='left')
                self.ed2name_tool.Pack(side='left')
                if (self.calc.get_parameter('ed2_specify')):
                    self.calc.set_parameter('ed2_path',dir+os.sep+name+'.ed2')
                    self.ed2path_tool.UpdateWidget()
                    self.ed2path_tool.Pack(side='left')
                else:
                    self.ed2path_tool.Forget()
            else:
                self.ed2path_tool.Forget()
                self.ed2name_tool.Forget()

        if (lfn =='ed3'):
            self.ed3keep_tool.ReadWidget()
            self.ed3name_tool.ReadWidget()
            if (self.calc.get_parameter('ed3_keep')):
                self.ed3path_tool.Pack(side='left')
                self.ed3name_tool.Pack(side='left')
                if (self.calc.get_parameter('ed3_specify')):
                    self.calc.set_parameter('ed3_path',dir+os.sep+name+'.ed3')
                    self.ed3path_tool.UpdateWidget()
                    self.ed3path_tool.Pack(side='left')
                else:
                    self.ed3path_tool.Forget()
            else:
                self.ed3path_tool.Forget()
                self.ed3name_tool.Forget()

        if (lfn =='ed7'):
            self.ed7keep_tool.ReadWidget()
            self.ed7name_tool.ReadWidget()
            if (self.calc.get_parameter('ed7_keep')):
                self.ed7path_tool.Pack(side='left')
                self.ed7name_tool.Pack(side='left')
                if (self.calc.get_parameter('ed7_specify')):
                    self.calc.set_parameter('ed7_path',dir+os.sep+name+'.ed7')
                    self.ed7path_tool.UpdateWidget()
                    self.ed7path_tool.Pack(side='left')
                else:
                    self.ed7path_tool.Forget()
            else:
                self.ed7path_tool.Forget()
                self.ed7name_tool.Forget()

        if (lfn =='ed14'):
            self.ed14keep_tool.ReadWidget()
            if (self.calc.get_parameter('ed14_keep')):
                self.ed14path_tool.Pack(side='left')
            else:
                self.ed14path_tool.Forget()
                
    def __restartcalc(self):
        """If this is a restart calculation, display the relevant widgets.
        """
        self.restartcalc_tool.ReadWidget()
        if self.calc.get_parameter('restart'):
            self.restarttype_tool.Pack()
            self.restartbypass_tool.Pack()
        else:
            self.restarttype_tool.Forget()
            self.restartbypass_tool.Forget()

    def __getenvironment(self):
        """Work out some sensible defaults for the locations of things
           - currently just the lib directory.
        """
        if sys.platform[:3] == 'win':
            try:
                ed0_path = os.environ('GAMESS_LIB')
            except:
                ed0_path = os.getcwd()
                
        elif sys.platform[:3] == 'mac':
            print "Help!  - still havent got round to supporting the Mac yet!"
            
        else:
            try:
                from jobmanager import subprocess
                cmd="rungamess -V"
                p = subprocess.ForegroundPipe(cmd)
                code = p.run()
                dict = {}
                for l in p.output:
                    w = l.split()
                    dict[w[0]]=w[1]
                ed0_path = dict['GAMESS_LIB']
            except:
                ed0_path = os.getcwd()

        self.calc.set_parameter('ed0_path',ed0_path)
            
    def summarise_results(self):
        """ Use John Kendrick's output reader to scan a gamessuk
            output file and summarise the results.
        """
        print 'scanning output...'
        # John's stuff
        calcdir = self.calc.get_parameter("directory")
        if self.calc.has_parameter("job_name"):
            name = self.calc.get_parameter("job_name")
        else:
            name = self.calc.get_name()
        fname = os.path.join(calcdir,name+".out")
        
        if not os.path.exists(fname):
            fname = tkFileDialog.askopenfilename(initialfile = name+".out",
                                                 initialdir = calcdir,
                                                 filetypes=[("Output Files","*.out"),])
            if len(fname) == 0:
                return

        try:
            if self.summaryeditor:
                try:
                    self.summaryeditor.withdraw()
                    self.summaryeditor.show()
                    return
                except:
                    print "Missing summary editor!"
            else:
                data = []
                output_summary = GamessOutputReader(fname)
                data.append('Title = %s\n' % output_summary.title)
                data.append('Date = %s\n' % output_summary.date)
                data.append('Time = %s\n' % output_summary.time)
                data.append('Multiplicity = %s\n' %output_summary.multiplicity)
                data.append('Charge = %s\n' %output_summary.charge)
                data.append('No. of electrons = %s\n' %output_summary.nelec)
                data.append('Basis set = %s\n' %output_summary.basis)
                data.append('No. basis functions = %s\n' %output_summary.nbasis)
                data.append('No. of shells = %s\n' %output_summary.nshells)
                data.append('Symmetry = %s\n' %output_summary.pointGroup)
                data.append('Order of principle axis = %s\n' %output_summary.orderOfPrincipalAxis)
                data.append('Nuclear energies: %s\n' %output_summary.nuclearEnergies)
                data.append('Electronic energies: %s\n' %output_summary.electronicEnergies)
                data.append('Total energies: %s\n' %output_summary.totalEnergies)
                data.append('Final nuclear energy = %s\n' %output_summary.finalNuclearEnergy)
                data.append('Final electronic energy = %s\n' %output_summary.finalElectronicEnergy)
                data.append('Final total energy = %s\n' %output_summary.finalTotalEnergy)
                data.append('Orbital Irreps: %s\n' %output_summary.orbitalIrreps)
                data.append('Orbital energies: %s\n' %output_summary.orbitalEnergies)
                data.append('Orbital occupancies: %s\n' %output_summary.orbitalOccupancies)
                data.append('Mulliken pops: %s\n' %output_summary.mullikens)
                data.append('Lowdin pops: %s\n' %output_summary.lowdins)
                data.append('Scftypes: %s\n' %output_summary.scftypes)
                data.append('Runtypes: %s\n' %output_summary.runtypes)
                data.append('Convergence: %s\n' %output_summary.maximumSteps)
                data.append('Converged = %s\n' %output_summary.converged)
                data.append('homo = %s\n' %output_summary.homo)
                data.append('lumo = %s\n' %output_summary.lumo)
                data.append('Nuclear Dipole:%s\n' % output_summary.nuclearDipole)
                data.append('Electronic Dipole:%s\n' % output_summary.electronicDipole)
                data.append('Total Dipole:%s\n' % output_summary.totalDipole)
                self.summaryeditor = Editor(self.interior(),title="summary",data=data)
                return 
        except AttributeError:
            print 'No results to summarise'


    def LayoutToolsTk(self):
        """Place the widgets belonging to the tools (ChargeTool etc)
        This will generally be replaced by a more specific function
        for a particular code interface.
        """
        #Add Molecule tab
        page = self.notebook.add('Molecule',tab_text='Molecule')
        
        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Molecule')
        viewer.help.sethelp(tab,'Molecule Tab')
        
        page.optgroup = Pmw.Group(page,tag_text="Options")
        page.optgroup.pack(expand='yes',fill='both')
        page.basisgroup = Pmw.Group(page,tag_text="Basis Selector")
        page.basisgroup.pack(expand='yes',fill='both')

        self.title_tool.widget.pack(in_=page.optgroup.interior())
        self.task_tool.widget.pack(in_=page.optgroup.interior())
        self.scfmethod_tool.widget.pack(in_=page.optgroup.interior())
        self.charge_tool.widget.pack(in_=page.optgroup.interior())
        self.spin_tool.widget.pack(in_=page.optgroup.interior())
        self.checkspin_widget.pack(in_=page.optgroup.interior())
        self.symmetry_tool.widget.pack(in_=page.optgroup.interior())

        Pmw.alignlabels([self.charge_tool.widget, self.spin_tool.widget])
        self.basis_tool.widget.pack(in_=page.basisgroup.interior())

        #Add Theory tab
        page = self.notebook.add('Theory',tab_text='Theory')
        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Theory')
        viewer.help.sethelp(tab,'Theory Tab')
        
        page.guessgroup = Pmw.Group(page,tag_text="Guess")
        page.guessgroup.pack(expand='yes',fill='both')
        self.guessoption_tool.widget.pack(in_=page.guessgroup.interior(),side='left')
        page.guessframe = Tkinter.Frame(page.guessgroup.interior())
        page.guessframe.pack(in_=page.guessgroup.interior(),side='left')
        self.guessatoms_tool.SetParent(page.guessframe)
        self.guesssection1_tool.SetParent(page.guessframe)
        self.guesssection2_tool.SetParent(page.guessframe)
        self.guessgetqblock1_tool.SetParent(page.guessframe)
        self.guessgetqsection1_tool.SetParent(page.guessframe)
        self.guessgetqblock2_tool.SetParent(page.guessframe)
        self.guessgetqsection2_tool.SetParent(page.guessframe)

        page.scfgroup = Pmw.Group(page,tag_text="SCF")
        page.scfgroup.pack(expand='yes',fill='both')
        self.scfmethod_tool.widget.pack(in_=page.scfgroup.interior())
        self.scfmaxcycles_tool.widget.pack(in_=page.scfgroup.interior())
        self.scfthreshold_tool.widget.pack(in_=page.scfgroup.interior())
        self.scfbypass_tool.widget.pack(in_=page.scfgroup.interior())

        page.scflevelgroup = Pmw.Group(page,tag_text="SCF Level Shifters")
        page.scflevelgroup.pack(in_=page.scfgroup.interior(),
                                expand='yes',
                                fill='both',
                                padx=10,
                                pady=10)
        self.scflevelinit_tool.widget.pack(in_=page.scflevelgroup.interior())
        self.scflevelit_tool.widget.pack(in_=page.scflevelgroup.interior())
        self.scflevelfinal_tool.widget.pack(in_=page.scflevelgroup.interior())

        page.postscfgroup = Pmw.Group(page,tag_text="Post SCF")
        page.postscfgroup.pack(expand='yes',fill='both')

        self.postscfmethod_tool.widget.pack(in_=page.postscfgroup.interior())

        
        #Add DFT tab
        page = self.notebook.add('DFT',tab_text='DFT')
        # Associate helpfile with notebook frame
        tab = self.notebook.tab('DFT')
        viewer.help.sethelp(tab,'DFT Tab')
        
        page.dftgroup1 = Pmw.Group(page,tag_text="Functional")
        page.dftgroup1.pack(expand='yes',fill='both')
        page.dftgroup2 = Pmw.Group(page,tag_text="Accuracy")
        page.dftgroup2.pack(expand='yes',fill='both')
        page.dftgroup3 = Pmw.Group(page,tag_text="Quadrature Types")
        page.dftgroup3.pack(expand='yes',fill='both')
        #page.dftgroup4 = Pmw.Group(page,tag_text="DFT Options4")
        #page.dftgroup4.pack(expand='yes',fill='both')
        page.dftgroup5 = Pmw.Group(page,tag_text="Coulomb Fitting")
        page.dftgroup5.pack(expand='yes',fill='both')


        self.dftfunctional_tool.widget.pack(in_=page.dftgroup1.interior())
        self.dftaccuracy_tool.widget.pack(in_=page.dftgroup2.interior())
        self.dftweightscheme_tool.widget.pack(in_=page.dftgroup2.interior())        
        self.dftradial_tool.widget.pack(in_=page.dftgroup3.interior(),side='top')
        self.dftangular_tool.widget.pack(in_=page.dftgroup3.interior(),side='top')
        
        self.dftjfit_tool.SetParent(page.dftgroup5.interior())
        self.dftjfit_tool.Pack()
        self.dftjbas_tool.SetParent(page.dftgroup5.interior())
        self.dftschwarz_tool.SetParent(page.dftgroup5.interior())

        # Add Properties tab
        page = self.notebook.add('Properties',tab_text='Properties')
        
        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Properties')
        viewer.help.sethelp(tab,'Properties Tab')
        
        page.grgroup = Pmw.Group(page,tag_text="Graphical options")

        page.grgroup.pack(expand='yes',fill='x')

        page.mogroup = Pmw.Group(page.grgroup.interior(),tag_text="Orbital Plots")
        page.mogroup.pack(expand='yes',fill='x',side='right')
        self.homolumo_tool.widget.pack(in_=page.mogroup.interior())
        self.homolumo1_tool.widget.pack(in_=page.mogroup.interior())
        self.homolumo2_tool.widget.pack(in_=page.mogroup.interior())
        self.homolumo3_tool.widget.pack(in_=page.mogroup.interior())
        self.homolumo4_tool.widget.pack(in_=page.mogroup.interior())
        self.homolumo5_tool.widget.pack(in_=page.mogroup.interior())

        f = Frame(page.grgroup.interior())
        f.pack(expand='yes',fill='x',side='left')
        page.group2 = Pmw.Group(f,tag_text="Density and Potential")
        page.group2.pack(expand='yes',fill='x',side='top')
        self.chargeden_tool.widget.pack(in_=page.group2.interior())
        self.diffden_tool.widget.pack(in_=page.group2.interior())
        self.potential_tool.widget.pack(in_=page.group2.interior())
        self.chargedengrad_tool.widget.pack(in_=page.group2.interior())
        self.spinden_tool.widget.pack(in_=page.group2.interior())

        page.editgrid_button = Tkinter.Button(f,command=self.edit_grid)
        page.editgrid_button.config(text="Edit Grid")
        page.editgrid_button.pack(side='bottom',padx=10,pady=20)

        page.vgroup = Pmw.Group(page,tag_text="Frequencies")
        page.vgroup.pack(expand='yes',fill='x')
        self.frequencies_tool.widget.pack(in_=page.vgroup.interior())
        self.hessian_tool.widget.pack(in_=page.vgroup.interior())

        Pmw.alignlabels([self.homolumo_tool.widget,
                         self.homolumo1_tool.widget,
                         self.homolumo2_tool.widget,
                         self.homolumo3_tool.widget,
                         self.homolumo4_tool.widget,
                         self.homolumo5_tool.widget])

        Pmw.alignlabels([self.potential_tool.widget,
                         self.chargeden_tool.widget,
                         self.diffden_tool.widget,
                         self.chargedengrad_tool.widget,
                         self.spinden_tool.widget,
                         page.editgrid_button])


        #Add Optimisation tab
        page = self.notebook.add('Optimisation',tab_text='Optimisation')
        
        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Optimisation')
        viewer.help.sethelp(tab,'Optimisation Tab')
        
        page.rungroup = Pmw.Group(page,tag_text="Runtype")
        page.rungroup.pack(expand='yes',fill='both')
        self.optcoords_tool.widget.pack(in_=page.rungroup.interior())
        self.find_ts_tool.widget.pack(in_=page.rungroup.interior())

        page.searchgroup = Pmw.Group(page,tag_text="Search Procedure")
        page.searchgroup.pack(expand='yes',fill='both')
        self.optmaxcyc1_tool.SetParent(page.searchgroup.interior())
        self.optmaxcyc1_tool.Pack()
        self.optmaxcyc2_tool.SetParent(page.searchgroup.interior())
        self.optmaxcyc2_tool.Pack()
        self.optxtol_tool.SetParent(page.searchgroup.interior())
        self.optxtol_tool.Pack()
        self.optstepmax_tool.SetParent(page.searchgroup.interior())
        self.optstepmax_tool.Pack()
        self.optvalue_tool.SetParent(page.searchgroup.interior())
        self.optvalue_tool.Pack()
        Pmw.alignlabels([self.optmaxcyc1_tool.widget, self.optmaxcyc2_tool.widget,
                         self.optxtol_tool.widget, self.optstepmax_tool.widget,
                         self.optvalue_tool.widget])
        
        page.jorggroup = Pmw.Group(page,tag_text="Jorgensen-Simons Algorithm")
        page.jorggroup.pack(expand='yes',fill='both')
        self.optjorg_tool.SetParent(page.jorggroup.interior())
        self.optjorg_tool.Pack()
        self.optpowell_tool.SetParent(page.jorggroup.interior())
        self.optbfgs_tool.SetParent(page.jorggroup.interior())
        self.optminhess_tool.SetParent(page.jorggroup.interior())
        self.optmaxhess_tool.SetParent(page.jorggroup.interior())
        self.optrfo_tool.SetParent(page.jorggroup.interior())
        Pmw.alignlabels([self.optjorg_tool.widget, self.optpowell_tool.widget,
                         self.optbfgs_tool.widget, self.optminhess_tool.widget,
                         self.optmaxhess_tool.widget, self.optrfo_tool.widget])

        #Add Job tab
        page = self.notebook.add('Job',tab_text='Job')

        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Job')
        viewer.help.sethelp(tab,'Job Tab')
        
        page.jobgroup = Pmw.Group(page,tag_text="Job Group")
        page.jobgroup.pack(side='top',expand='yes',fill='both')

        self.jobname_tool.widget.pack(in_=page.jobgroup.interior())
        self.workingdirectory_tool.widget.pack(in_=page.jobgroup.interior())
        self.submission_frame = Tkinter.Frame(page.jobgroup.interior())
        self.submission_frame.pack()
        self.submission_config_button = Tkinter.Button(self.submission_frame,
                                                       text='Configure...',
                                                       command=self.configure_jobSubmitEd)
        self.submission_tool.widget.pack(in_=self.submission_frame,side='left')

        #Add Restart group
        page.fpathgroup = Pmw.Group(page,tag_text="File Path Group")
        page.fpathgroup.pack(expand='yes',fill='both')

        #Need to create multiple frames so things can be packed and forgotten
        # without the order getting all jumbled.
        page.ed0frame = Tkinter.Frame(page.fpathgroup.interior())
        page.ed0frame.pack(in_=page.fpathgroup.interior(),side='top',
                             expand='yes', fill='both')
        ed0label = Tkinter.Label(page.ed0frame, text='ECP Libraries (ed0) ')
        ed0label.pack(side='left')
        self.ed0keep_tool.SetParent(page.ed0frame)
        self.ed0path_tool.SetParent(page.ed0frame)
        self.ed0keep_tool.widget.pack(in_=page.ed0frame, side='left')

        page.ed2frame = Tkinter.Frame(page.fpathgroup.interior())
        page.ed2frame.pack(in_=page.fpathgroup.interior(),side='top',
                             expand='yes', fill='both')
        ed2label = Tkinter.Label(page.ed2frame, text='Mainfile (ed2) ')
        ed2label.pack(side='left')
        self.ed2keep_tool.SetParent(page.ed2frame)
        self.ed2name_tool.SetParent(page.ed2frame)
        self.ed2path_tool.SetParent(page.ed2frame)
        self.ed2keep_tool.widget.pack(in_=page.ed2frame, side='left')

        page.ed3frame = Tkinter.Frame(page.fpathgroup.interior())
        page.ed3frame.pack(in_=page.fpathgroup.interior(),side='top',
                             expand='yes', fill='x')
        ed3label = Tkinter.Label(page.ed3frame, text='Dumpfile (ed3) ')
        ed3label.pack(side='left')
        self.ed3keep_tool.SetParent(page.ed3frame)
        self.ed3path_tool.SetParent(page.ed3frame)
        self.ed3name_tool.SetParent(page.ed3frame)
        self.ed3keep_tool.widget.pack(in_=page.ed3frame, side='left')

        page.ed7frame = Tkinter.Frame(page.fpathgroup.interior())
        page.ed7frame.pack(in_=page.fpathgroup.interior(),side='top',
                             expand='yes', fill='both')
        ed7label = Tkinter.Label(page.ed7frame, text='Tempfile (ed7) ')
        ed7label.pack(side='left')
        self.ed7keep_tool.SetParent(page.ed7frame)
        self.ed7name_tool.SetParent(page.ed7frame)
        self.ed7path_tool.SetParent(page.ed7frame)
        self.ed7keep_tool.widget.pack(in_=page.ed7frame, side='left')

        page.ed14frame = Tkinter.Frame(page.fpathgroup.interior())
        page.ed14frame.pack(in_=page.fpathgroup.interior(),side='top',
                             expand='yes', fill='both')
        ed14label = Tkinter.Label(page.ed14frame, text='Foreign Dumpfile (ed14) ')
        ed14label.pack(side='left')
        self.ed14keep_tool.SetParent(page.ed14frame)
        self.ed14path_tool.SetParent(page.ed14frame)
        self.ed14keep_tool.widget.pack(in_=page.ed14frame, side='left')

        Pmw.alignlabels([self.ed0keep_tool.widget,
                         self.ed0path_tool.widget,
                         self.ed2keep_tool.widget,
                         self.ed2path_tool.widget,
                         self.ed2name_tool.widget,
                         self.ed2keep_tool.widget,
                         self.ed3path_tool.widget,
                         self.ed3name_tool.widget,
                         self.ed3keep_tool.widget,
                         self.ed7path_tool.widget,
                         self.ed7name_tool.widget,
                         self.ed7keep_tool.widget,
                         self.ed14path_tool.widget,
                         self.ed14keep_tool.widget])
        

    def EditCoordinates(self,model=None):
        """Open a coordinate editor window
        This differs from the generic one only in that the variables can
        have keywords associated (e.g. type 3)
        """
        if self.calc.editing:
            print 'Calculation is already being edited'
        else:
            self.calc.editing = 1
            mol_name = self.calc.get_input('mol_name')
            mol_obj = self.calc.get_input('mol_obj')
            self.zme = ZME(self.root,
                           model=mol_obj,
                           reload_func=self.reload_for_zme,
                           update_func=self.update_for_zme,
                           v_key=1)


def copycontents(to,fro):
    """Used to update an object by copying in the contents from another"""
    c = to.__class__
    d1 = c.__dict__
    try:
        d2 = fro.__dict__
    except AttributeError:
        d2 = {}
    for k in d2.keys():
        to.__dict__[k] = fro.__dict__[k]


def prdict(obj,name,depth):

    try:
        myclass = obj.__class__
    except:
        myclass = ""

    for i in range(depth):
        print "   ",
    print name, obj, myclass

    try:
        dicts = obj.__dict__.keys()
    except AttributeError:
        dicts = []

    for y in dicts:
        o = obj.__dict__[y]
        prdict(o,y,depth+1)


def pickler(obj):

    obj.g = None

    prdict(obj,'TOP',0)

    sfile='junk.pkl'
    fobj = open(sfile,'w')

    p = pickle.Pickler(fobj)
        
    try:
        p.dump(obj)
    except pickle.PicklingError, e:
        print 'X'
        print e.__class__
        print e.args

    fobj.close()
    

if __name__ == "__main__":
    
    from interfaces.gamessuk import *
    from objects.zmatrix import *
    from jobmanager import *
    model = Zmatrix()
    atom = ZAtom()
    atom.symbol = 'C'
    atom.name = 'C'
    model.insert_atom(0,atom)
    atom = ZAtom()
    atom.symbol = 'Cl'
    atom.name = 'Cl'
    atom.coord = [ 1.,0.,0. ]
    model.insert_atom(1,atom)
    atom = ZAtom()
    atom.symbol = 'H'
    atom.name = 'H'

    atom.coord = [ 1.,1.,0. ]
    model.insert_atom(1,atom)

    calc = GAMESSUKCalc()

    root=Tk()

    #button = Tkinter.Button(root,text='pickle',command=lambda obj=calc: pickler(obj))
    #button.pack()
    if 1:
        from viewer.rc_vars import rc_vars
        rc_vars[ 'machine_list'] = ['lake.esc.cam.ac.uk']
        rc_vars[ 'nproc'] = '1'
        rc_vars['srb_config_file'] ='/home/jmht/srb.cfg'
        rc_vars['srb_executable'] = 'gamess'
        rc_vars['srb_executable_dir'] = '/home/jmht.eminerals/test/executables'
        rc_vars['srb_input_dir'] = '/home/jmht.eminerals/test/test1'
        rc_vars['srb_output_dir'] = '/home/jmht.eminerals/test/test1'
        rc_vars['rmcs_user'] = 'jmht'
        rc_vars['rmcs_password'] = '4235227b51436ad86d07c7cf5d69bda2644984de'
        rc_vars['myproxy_user'] = 'jmht'
        rc_vars['myproxy_password'] = 'pythonGr1d'
        rc_vars['gamessuk_exe'] = '/home/jmht/GAMESS-UK/GAMESS-UK-7.0/bin/gamess'
        
        calc.set_input('mol_obj',model)
        jm = JobManager()
        je = JobEditor(root,jm)
        calc2 = copy.deepcopy(calc)
        vt = GAMESSUKCalcEd(root,calc,None,job_editor=je)
        #vt.Run()
    root.mainloop()
