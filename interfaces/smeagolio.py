#
#    This file is part of the CCP1 Graphical User Interface (ccp1gui)
# 
#   (C) 2002-2005 CCLRC Daresbury Laboratory
# 
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
# 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#
# Read a data file output by Smeagol
import os,sys
if __name__ == "__main__":
    # Need to add the gui directory to the python path so 
    # that all the modules can be imported
    gui_path = os.path.split(os.path.dirname( os.path.realpath( __file__ ) ))[0]
    sys.path.append(gui_path)
else:
    from viewer.paths import gui_path

# import python modules
import math
import unittest

# import local modules
import objects.field
import objects.vector

# import external modules
import vtk # We create the VTK objects directly
from fileio import FileIO

class SmeagolIO(FileIO):
   """
      Load objects from the files generated by Smeagol
   """

   def __init__(self, filepath=None,**kw):
      """ Set up the structures we need
      
      """
      
      # Initialise base class
      FileIO.__init__(self,filepath=filepath,**kw)
      
      # List which types of object we can read/write
      self.canRead = True
      self.canWrite = []


   def _ReadFile(self,**kw):
       """ Read in the data from an RHO file.
       
           Format of the file is expected to be:
           
           1: Z lattice vector - float(x) float(y) float(z)
           2: Y lattice vector - float(x) float(y) float(z)
           3: X lattice vector - float(x) float(y) float(z)
           4: zdim ydim xdim nspin - number of mesh points in each direction
                                     plus the number of spins - if nspin=2 then
                                     we are creating 2 datasets
           5:data...               - list of data points as floats
       """
       

       f = open( self.filepath, 'r')
              
       # Read in the first 4 lines containing the grid definition
       # and the dimensions & spin
       zline   = f.readline().strip()
       yline   = f.readline().strip()
       xline   = f.readline().strip()
       dimline = f.readline().strip()

       # Set up the Z lattice vector
       zLatVec = self.__get_latvec( zline )
       if not zLatVec:
          print "No Z Lattice Vector!"
          return 1

       # Set up the Y lattice vector
       yLatVec = self.__get_latvec( yline )
       if not yLatVec:
          print "No Z Lattice Vector!"
          return 1

       # Set up the X lattice vector
       xLatVec = self.__get_latvec( xline )
       if not xLatVec:
          print "No X Lattice Vector!"
          return 1


       # Get the dimensions & the number of spins
       fields = dimline.split()
       if ( len( fields ) != 4 ):
          raise Exception,"Problem with dimension line in smeagolreader read_grid_dimensions!"
       xDim,yDim,zDim,nspin = fields[0:4]
       xDim,yDim,zDim,nspin = int(xDim), int(yDim), int(zDim), int(nspin)

       #Work out how many data points we've got
       npoints = xDim * yDim * zDim

       # Now loop over the spins & read in the data points.
       # We assume that the origin is at the centre of the grid and that the data has been written
       # out starting at the origin, going to the edge and then being translated back
       # by the unit cell vector and writing out the remaining points back to the origin
       
       # Need to allocate memory for the data
       #data = []
       #for i in range(npoints):
       #   data.append(0)

       scalars = vtk.vtkFloatArray()
       scalars.SetNumberOfValues( npoints )

       for spin in range(nspin):
          #print "Reading data points from file..."
          for z in range(zDim):
             if ( z < (zDim/2) ):
                zt = z + (zDim/2)
             else:
                zt = z - (zDim/2)
             for y in range(yDim):
                if ( y < (yDim/2) ):
                   yt = y + (yDim/2)
                else:
                   yt = y - (yDim/2)
                for x in range(xDim):
                   if ( x < (xDim/2) ):
                      xt = x + (xDim/2)
                   else:
                      xt = x - (xDim/2)

                   #if not count % 10000:
                   #   print '...',
                      
                   line = f.readline()
                   if not line:
                      print "ERROR reading Data in smeagolreader!"
                      return None
                   
                   try:
                      dat = float(line)
                   except:
                      print "Bad Data in smeagol reader!: %s " % line
                      dat = float(-999999)
                      
                   offset = (zt * xDim * yDim) + (yt * xDim) + xt
                   #data[offset] = dat
                   scalars.SetValue( offset, dat )
                   
          #End of loop over z,x,y

          if ( nspin == 2):
             title = self.name + str(spin)
          else:
             title = self.name

          # Create the field object
          smgfield = self.create_vtkfield( title, scalars, zLatVec, yLatVec, xLatVec, \
                                      zDim, yDim, xDim )
          
          # Add the field to the list of objects
          if self.debug:
             print "smeagolreader appending field:"
             smgfield.list()
          self.fields.append( smgfield )
          

   def __get_latvec( self, line ):
      """ Take a line read in from the RHO file and return the
          relevant lattice vector as a list of floats
          REM: we need to convert from Bohrs -> Angstroms so we do
          this here.
      """
      
      bohr_2_angs = 0.529177
      
      x,y,z = line.split()
      x,y,z = float(x), float(y), float(z)
      x,y,z = x* bohr_2_angs, y* bohr_2_angs, z* bohr_2_angs
      return [ x, y, z ]

#   def create_vtkfield( self, title, data, zLatVec, yLatVec, xLatVec, zDim, yDim, xDim ):
   def create_vtkfield( self, title, scalars, zLatVec, yLatVec, xLatVec, zDim, yDim, xDim ):
      """ Create a field object that holds the data in a vtkImageData object
      """

      vtkdata = vtk.vtkImageData()
      vtkdata.SetDimensions( xDim, yDim, zDim )

      # work out the spacing
      # asume the grid origin is always at 0.0, 0.0, 0.0
      origin = [ 0.0, 0.0, 0.0 ]
      xlen = math.sqrt( math.pow( (origin[0] - xLatVec[0]), 2) + \
                        math.pow( (origin[1] - xLatVec[1]), 2) + \
                        math.pow( (origin[2] - xLatVec[2]), 2) )    
      xspacing = float( xlen/xDim )
      ylen = math.sqrt( math.pow( (origin[0] - yLatVec[0]), 2) + \
                        math.pow( (origin[1] - yLatVec[1]), 2) + \
                        math.pow( (origin[2] - yLatVec[2]), 2) )     
      yspacing = float( ylen/yDim )
      zlen = math.sqrt( math.pow( (origin[0] - zLatVec[0]), 2) + \
                        math.pow( (origin[1] - zLatVec[1]), 2) + \
                        math.pow( (origin[2] - zLatVec[2]), 2) )
      zspacing = float( zlen/zDim )
      vtkdata.SetSpacing( xspacing, yspacing, zspacing )

      #scalars = vtk.vtkFloatArray()
      #npoints = zDim * yDim * xDim
      #scalars.SetNumberOfValues( npoints )
      #for i in range( npoints ):
         # What on earth is the vtkIdType??? (1st arg)
         #scalars.SetValue( i, data[i] )
      #   scalars.InsertNextValue( data[i] )
         
      vtkdata.GetPointData().SetScalars(scalars)
      vtkdata.SetScalarTypeToFloat()

      # Work out the origin (assume it's at the centre of the grid)
      origin = [ -xlen / 2, -ylen / 2 , -zlen / 2 ]
      vtkdata.SetOrigin( origin )

      # Instantiate the field object
      field = objects.field.Field()
      field.title = title
      field.vtkdata = vtkdata

      # Need to add axis, dimensions & origin as these are required by the CutSlice visulaliser
      # NB: May need to use Vector as currently these are only lists?
      field.dim = [ xDim, yDim, zDim ]
      field.x = objects.vector.Vector( xLatVec )
      #field.axis.append( field.x )
      field.axis[0] = field.x 
      field.y = objects.vector.Vector( yLatVec )
      #field.axis.append( field.y )
      field.axis[1] = field.y
      field.z = objects.vector.Vector( zLatVec )
      #field.axis.append( field.z )
      field.axis[2] = field.z 
      #field.origin =objects.vector.Vector( origin )
      #jmht HACK - need to think about this
      field.origin =objects.vector.Vector( [0.,0.,0.] )

      

      return field

##########################################################
#
#
# Unittesting stuff goes here
#
#
##########################################################

class testSmeagol_IO(unittest.TestCase):
    """Test whether we deal with Smeagol data"""

    reader = SmeagolIO()

    def testRead(self):
        """ read in scalar data
        """

        fields = self.reader.GetObjects(
            filepath='/c/qcg/jmht/share/codes/ccp1gui/smeagol/Benz.short.rho',
            otype = 'fields'
            )

        self.assertEqual( fields[0].dim[0] , 90)

def testMe():
    """Return a unittest test suite with all the testcases that should be run by the main 
    gui testing framework."""

    return  unittest.TestLoader().loadTestsFromTestCase(testSmeagol_IO)


if ( __name__ == "__main__" ):
   unittest.main()
