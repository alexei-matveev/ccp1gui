#
#    This file is part of the CCP1 Graphical User Interface (ccp1gui)
# 
#   (C) 2002-2007 CCLRC Daresbury Laboratory
# 
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
# 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Implements the Dalton specific calculation (Calc) and
   calculation editor (CalcEd) classes
"""

import os
import string
import sys
import copy

import Tkinter
import Pmw
import tkFileDialog
import viewer.help

from qm import *
from tools import *
from qmtools import *
#from filepunch import *
from jobmanager import *
from viewer.paths import paths,find_exe
from viewer.defaults import defaults

from objects.periodic import *
#from daltonoutputreader import DaltonOutputReader
from daltonio import DaltonIO

MENU_ENER  = "Energy"
MENU_GRAD  = "Gradient"
MENU_OPT   = "Geometry Optimisation"

def fortranfloat( sfloat ):
    """ Take a float or python string representation of a float and return a string in a form
        suitable for reading in by a FORTRAN program.
        Not sure of the best place to put this yet
    """

    try:
        f = float( sfloat )
        f = "%E" % f
        ttab = string.maketrans('E','D')
        f = string.translate( f, ttab )
    except Exception, e:
        print "Error reading float in fortranfloat!: %s" %s
        f = None
        
    return f
   

class DALTONCalc(QMCalc):
    """Dalton specifics."""
    def __init__(self, **kw):

        apply(QMCalc.__init__,(self,),kw)

        #self.set_parameter("task",MENU_ENER)
        self.debug = 1
        
        self.set_program('Dalton')

        # Job and file parameters
        self.set_title('This file was generated by the CCP1 GUI')
        self.set_parameter('dalton_script',None)
        self.set_parameter('comment','No comment...')
        self.set_parameter('job_name','untitled')
        self.set_parameter('directory',paths['user'])
        self.set_parameter('setscratch',0)
        self.set_parameter('scratchdir','UNSET')
        self.set_parameter('setbasis',0)
        self.set_parameter('basisdir','.')
        self.set_parameter('keepscratch',0)
        self.set_parameter('molfilename','untitled')
        self.set_parameter('dalfilename','untitled')
        self.set_parameter('molfile',None)
        self.set_parameter('dalfile',None)


        #
        # see the basismanager for the form of 
        # the basis structure
        #
        self.set_parameter("default_basis","6-31G")
        self.set_parameter("basis",None)
        self.set_parameter("ECP",None)

        #Guess and Restart parameters
        self.set_parameter('restart',0)
        self.set_parameter('restart_type',0)


        #self.set_parameter("guess_method","Compute")
        self.set_parameter("guess","HUCKEL")

        # SCF Parameters
        # method vs scf_method - should be task?
        self.set_parameter("method","HF")
        self.set_parameter('direct',0);
        self.set_parameter("diis_maxcyc",60)
        self.set_parameter("scf_thresh",1.0E-6)
        self.set_parameter('symmetry',1)

        # DFT Parameters
        #self.set_parameter("dft_grid","NORMAL")
        self.set_parameter("dft_accuracy","NORMAL")
        self.set_parameter("dft_functional","BLYP")
        #self.set_parameter("dft_weights","MHL8SSF")
        self.set_parameter("dft_partitioning",None)

        # Geometry optimisation parameters
        self.set_parameter( 'geomopt', 0 )
        self.set_parameter( 'opt_order', 'First Order' )
        self.set_parameter( 'opt_iter', 25 )
        self.set_parameter( 'opt_conv', "Default" )
        self.set_parameter( 'opt_convE', 1.0E-6 )
        self.set_parameter( 'opt_convgrad', 1.0E-5 )
        self.set_parameter( 'opt_convstep', 1.0E-5 )
        self.set_parameter( 'preopt', 0 )
        self.set_parameter( 'preopt_basis', "STO-3G" )

        field = Field()
        field.dim[0] = 11
        field.dim[1] = 11
        field.dim[2] = 11
        self.set_parameter('grid',field)
        self.field_sized=0

        
        self.basis_manager = BasisManager()
        # Build up list of all basis sets supported by element
        self. __setup_keyword_basis()


    def get_editor_class(self):
        return DALTONCalcEd

    def WriteInput(self, nowrite=None, only_dal=None, only_mol=None ):
        """ Write out the Dalton input files. This takes the rather unintuitive optional
            parameter nowrite, which, if set, just creates the input for viewing and doesn't
            write any files. This used by the __updateinput method.
            if only_dal or only_mol are set, only write out the dal or mol files
            
        """

        #Get an editor object so we can pop up tk error widgets
        ed = self.get_editor()

        # Read all the widgets ( method from calced.py)
        ed.ReadWidgets()

        self.GetModel()
        mol_name = self.get_input("mol_name")
        mol_obj  = self.get_input("mol_obj")

        # See if the user had edited a job and changed any parameters
        job = self.get_job()
        workdir=None
        if job:
            workdir = job.get_parameter("local_directory")
        if not workdir:
            workdir = self.get_parameter('directory')

        # Check the spin of the molecule is o.k. before we do owt else.
        # ( don't do this if we are just updating the input displayed in the job tab as it gets v.annoying... )
        if ( not nowrite ):
            if self.CheckSpin(show=1):
                return None
        
        # Create the input for the .dal file & write out if necessary
        if not only_mol:
            dalfilename = self.get_parameter('dalfilename')
            dalfile = workdir+os.sep+dalfilename+'.dal'
            dal_input = []
            dal_input = self.__writedalfile( mol_obj )
            if not dal_input:
                ed.Error ( "There was a problem writing %s!" % dalfile )
                return 1
            else:
                self.set_input( 'input_file', dal_input )
                if ( not nowrite ):
                    d = open( dalfile, 'w' )
                    for line in dal_input:
                        d.write( line )
                    d.close()

        if only_dal:
            return

        # start to set up the input list that will be displayed in the window
        #input = dal_input
        #input.append( "\n\n\t***************\n" )

        # Create the .mol file and write it out if necessary
        molfilename = self.get_parameter( 'molfilename' )
        molfile = workdir+os.sep+molfilename+'.mol'
        mol_input = []
        mol_input = self.__writemolfile( mol_obj )
        if not mol_input:
            ed.Error ( "There was a problem writing %s!" % molfile )
            return 1
        else:
            self.set_input( 'mol_input', mol_input )
            if ( not nowrite ):
                m = open( molfile, 'w' )
                for line in mol_input:
                    m.write( line )
                m.close()

        if only_mol:
            return

        # Create an input that consists of both dal_input & mol_input
        all_input = copy.copy(dal_input)
        all_input.append( "\n\n\t==*******************************==\n" )
        all_input = all_input + mol_input
        
        self.set_input( "all_input", all_input )

        # Set up the jobname and the dal and mol files
        # need to be careful as this is different depending on whether the names differ or not
        if ( dalfilename == molfilename ):
            job_name = dalfilename
        else:
            job_name = dalfilename + "_" + molfilename
            
        self.set_parameter( "job_name", job_name )
        self.set_parameter( "molfile", molfile )
        self.set_parameter( "dalfile", dalfile )

        return [ molfile, dalfile ]


    def makejob(self,writeinput=None,graph=None):
        """Prepare the Dalton job:
        1) Generate the input-file
        2) Construct the sequence of job steps
        """
        #Get an editor instance to pop up tk-error widgets
        ed = self.get_editor()

        # Not sure about this but Paul said it might be important
        self.GetModel()
        
        if writeinput:
            ret = self.WriteInput()
            if not ret:
                print "Dalton makejob writeinput - error writing job"
                return None
        # Make sure the files exist and have owt in them
        else:
            err_msg = "Trying to run a calculation with an empty .mol file!\n" +\
                      "Please make sure you have written a valid Dalton moleclue file."
            try:
                molfile = self.get_parameter( 'molfile' )
                size = os.path.getsize( molfile )
                if ( size == 0 ):
                    ed.Error( err_msg )
                    return None
                #except IOError,e:
            except os.error,e:
                ed.Error( err_msg )
                return None

            err_msg = "Trying to run a calculation with an empty .dal file!\n" +\
                      "Please make sure you have written a valid Dalton input file."
            try:
                dalfile = self.get_parameter( 'dalfile' )
                size = os.path.getsize( dalfile )
                if ( size == 0 ):
                    ed.Error( err_msg )
                    return None
            except os.error,e:
                ed.Error( err_msg )
                return None

        #  Get/create job of type specified by the submission parameter
        job = self.get_job()
        if not job:
            job = self.create_job()

        jobtype = job.jobtype
        job.name = self.get_parameter('job_name')

        if job.get_parameter("local_directory"):
            workdir = job.get_parameter('local_directory')
            self.set_parameter('directory',workdir)
        else:
            workdir = self.get_parameter('directory')
            
        dalfilename = self.get_parameter('dalfilename')
        molfilename = self.get_parameter('molfilename')

        dalton_script = job.get_parameter('executable')
        print "got script from job: ",dalton_script
        # Get the script to run the job
        if not dalton_script:
            raise CalcError,"Cannot run the calculation as no executable!\nPlease either put the dalton script in your path or use the job tab to set the path"

        try:
            os.chdir(workdir) #Run job in the specified directory
            print "job running from ",workdir
        except Exception,e:
            raise CalcError,"Cannot cd to working directory: %s\n%s" % (workdir,e)

        if jobtype == LOCALHOST:
            # We purge Windows here and assume that all other platforms are o.k.
            if sys.platform[:3] == 'win':
                ed.Error("Dalton on Windows?!? - I think not... :-)")
                return None
        else:
            raise CalcError,"dalton makejob - unsupported jobtype: %s" % jobtype
        
        # Now need to build up the arguments to the dalton script depending on what
        # options the user has chosen. These are built up as a list
        
        # workdir always gets set
        workdir = self.get_parameter('directory')
        args = [ '-w', workdir ]
        
        # Optional parameters
        if self.get_parameter( 'setbasis' ):
            args += ['-b', self.get_parameter('basisdir') ]
        if self.get_parameter( 'setscratch' ):
            args += ['-t', self.get_parameter('scratchdir') ]
        if self.get_parameter( 'keepscratch' ):
            args += ['-D']

        args += [ dalfilename, molfilename]

        job.add_step(RUN_APP,
                     'run dalton shell-script',
                     local_command=dalton_script,
                     local_command_args=args,
                     stdout_file = "daltonstd.out" )
        
        job.add_tidy( self.endjob )
        
        return job

    def set_job_defaults(self,job):
        """Set any default parameters for calculations with this type of job
           This method should be overwritten (if need be) in any derived class.
        """

        script = job.get_parameter( 'executable' )
        if not script:
            script = find_exe( 'dalton' )
            if script:
                job.set_parameter( 'executable',script )

        if self.debug:
            print "calc set_job_defaults"

        # Always set the working directory to the directory parameter of the calc
        if job.jobtype == LOCALHOST:
            if not job.get_parameter( 'local_directory' ):
                job.set_parameter( 'local_directory', self.get_parameter('directory') )

    def endjob(self,job_status_code):
        """This function is executed in the main thread"""

        if self.debug:
            print 'running endjob code=',job_status_code

        # Get an editor so we can display messages and access the main graph object
        ed = self.get_editor()

        # Jens - need to think about a ReadOutput and ReadInput
        # this just for testing purposes
        job_name = self.get_parameter("job_name")
        workdir = self.get_parameter("directory")

        # Get the stdout
        stdout=[]
        try:
            stdoutfile = open("daltonstd.out")
            stdout = stdoutfile.readlines()
            stdoutfile.close()
        except Exception,e:
            ed.Error("WARNING! - Problem getting output of Dalton Script!\n%s" %e)
            stdout = ["Error Getting output of Dalton Script!\n",e]

        self.set_output( "script_stdout",  stdout )        

        # Get the output file
        readout=[]
        try:
            outputfile = open( workdir + os.sep + job_name + ".out" )
            readout = outputfile.readlines()
            outputfile.close()
            self.set_output( "dalton_output", readout )
        except Exception,e:
            raise Exception,"Error getting Dalton output in endjob: %s" % e


        # Merge the stdout and output to give a full output
        all_output = stdout  +  ["\n\t===*** END OF DALTON SCRIPT OUTPUT ***==\n"] + readout

        #self.set_output( "all_output", all_output )

        self.set_output( "log_file",all_output )


        d = DaltonIO(olist=copy.copy(all_output),debug=None)
        objects = d.GetObjects()
        if objects:
            for o in objects:
                self.results.append(o)
                
            # Load the results up - will present a dialog
            code = self.store_results_to_gui()


    def __writemolfile(self,molecule):
        """ Build up the list of strings containing the molecule input file. This is
            then returned to whatever called us for either display or writing out to file.
            the list is called 'm' for conciseness.
        """

        m = [] # the list that will hold the molfile input
        
        #Get an editor object so we can pop up tk error widgets
        ed = self.get_editor()

        # Dalton does not support mixed Cartesian / internal coords). So we check all
        # atom representations are consistent
        z_or_c = molecule.atom[0].zorc # check first atom
        
        for atom in molecule.atom:
            if atom.zorc != z_or_c:
                ed.Error("Molecule contains mixed Cartesian/Internal Coordinates!\n"+
                         "Please make sure you stick with one representation.")
                return None

        # Build a dictionary mapping atom types -> list of atoms of that type
        atom_types = {}
        natom = 0
        for atom in molecule.atom:
            natom += 1
            name = atom.name
            if not atom_types.has_key( name ):
                atom_types[name] = []
            atom_types[name].append( atom )
        natom_types = len( atom_types.keys() )
        

        # Sort out what basis set/s we are working with:
        
        # Check if any atoms types have explicitly defined basis sets - if so
        # we'll use the atombasis format, otherwise, just use the BASIS keyword
        #
        atombasis = None
        for atype in atom_types.keys():
            c = self.basis_manager.check_assigned_types( atype )
            if ( c == 1 ):
                atombasis = 1

        # Need this here as used in both writing input & check for atombasis
        usesymm = self.get_parameter('symmetry')
        
        if ( atombasis ):
            if ( z_or_c == 'z'):
                ed.Error("Molecule in Z-Matrix format, but atoms have explicit basis sets!\n"+
                     "For Z-matrix format, all atoms must have the same basis.")
                return None
            elif ( usesymm ):
                answer = ed.Query("The use of symmetry has been requested but different atom types\n"+
                                  "have different basis sets defined. Problems can arise if atom types\n"+
                                  "with the same charge have diffferent basis sets. Continue?")
                if ( answer == "Yes" ):
                    m.append("ATOMBASIS\n")
                else:
                    return None
            else:
                m.append("ATOMBASIS\n")
        else: # this for both z-matrix & cartesian formats
            m.append( "BASIS\n" )
            userbasis = self.get_parameter('basis')
            if userbasis:
                basis = self.basis_manager.default_basis
            else: # Use default
                basis = self.get_parameter( "default_basis" )
            m.append( basis + '\n' )

        # Title and comment
        m.append(self.get_title()+'\n')
        m.append(str(self.get_parameter("comment"))+'\n')
 
        # Write out z-matrix input and then return
        # REM - for Zmat, Atomtypes == natom, NOT natom_types!
        if ( z_or_c == 'z' ):
            m.append( "Atomtypes=%u\n" % natom )
            zmat = self.write_dalton_zmatrix( molecule )
            for line in zmat:
                m.append( line )
            return m

        # From here on we are dealing with a Cartesian output
        molcharge = self.get_parameter('charge')

        if usesymm:
            m.append("Atomtypes=%u Charge=%d\n" % ( natom_types, molcharge ) )
        else:
            m.append("Atomtypes=%u Charge=%d Nosymmetry\n" % ( natom_types, molcharge ) )
            
        for atype in atom_types.keys():
            element = molecule.get_element_from_tag( atype )
            charge = float( sym2no[element] )
            natoms = len( atom_types[atype] )
            if atombasis:
                basis = self.basis_manager.keybasis_from_type( atype )
                m.append("Charge=%.1f Atoms=%u Basis=%s\n"  % ( charge, natoms , basis ) )
            else:
                m.append("Charge=%.1f Atoms=%s\n"  % ( charge, natoms ) )
            for atom in atom_types[atype]:
                # Dalton uses Bohrs, the GUI Angstrom, so need to convert.
                angs_2_bohr = eval( "1 / 0.529177" )
                x = atom.coord[0] * angs_2_bohr
                y = atom.coord[1] * angs_2_bohr
                z = atom.coord[2] * angs_2_bohr
                m.append("%-4s  %13.10f  %13.10f  %13.10f\n" %
                           ( atype, x, y, z ) )

        # Input constuction finishes here
        return m
    
    def write_dalton_zmatrix(self, molecule):
        """ This takes a molecule and then builds up a list of strings containing
            the z-matrix and returns it - the list is called z.
            We have already checked that all atoms are in z-matrix format
            so can use the Zmatrix.atom_list_novar method to get the values
            and then just format things accordingly.
            REM - for zmatricies, need to work in Angstroms - NOT Bohrs
        """
        
        #angs_2_bohr = 0.529177

        z = [] # the list that will hold the z-matrix
        z.append( "ZMAT\n" )

        # Order the zmatrix - after this I am assuming they are in the correct
        # order to just be processed with the for.. iterator method
        molecule.reindex()

        index = 0
        for atom in molecule.atom:
            index += 1
            fields = molecule.atom_list_novar( atom )
            if len( fields ) == 3 :
                name = fields[1]
                charge = fields[2]
                z.append( "%-4s  %3u  %4.1f\n" % ( name, index, charge ) )
            elif len( fields ) == 5 :
                name = fields[1]
                conn1 = int ( fields[2] )
                r = float ( fields[3] )  #* angs_2_bohr
                charge = fields[4] 
                z.append( "%-4s  %3u  %3u  %7.4f  %4.1f\n" % ( name, index, conn1, r, charge ) )
            elif len( fields ) == 7 :
                name = fields[1]
                conn1 = int ( fields[2] )
                r = float ( fields[3] )  #* angs_2_bohr
                conn2 = int ( fields[4] )
                theta = float ( fields[5] )
                charge = fields[6]
                z.append( "%-4s  %3u  %3u  %7.4f  %3u  %7.4f  %4.1f\n" %
                         ( name, index, conn1, r, conn2, theta, charge ) )
            elif len( fields ) == 9 :
                name = fields[1]
                conn1 = int ( fields[2] )
                r = float ( fields[3] )  #* angs_2_bohr
                conn2 = int ( fields[4] )
                theta = float ( fields[5] )
                conn3 = int ( fields[6] )
                phi = float ( fields[7] )
                charge = fields[8]
                z.append( "%-4s  %3u  %3u  %7.4f  %3u  %7.4f  %3u  %7.4f  0 %4.1f\n" %
                         ( name, index, conn1, r, conn2, theta, conn3, phi, charge ) )
                
        z.append( "\n" )

        return z


    def __writedalfile(self, molecule ):
        """ Build up a list of strings for a dalton.dal file
        """

        i = [] # the list of strings we will be returning
        
        #Get an editor object so we can pop up tk error widgets
        ed = self.get_editor()


        # Write out the DALTON INPUT section
        i.append( "**DALTON INPUT\n")

        geomopt = self.get_parameter( 'geomopt' )
        if not geomopt:
            i.append( ".RUN WAVE FUNCTION\n" )
        else:
            i.append( ".OPTIMIZE\n" )

        direct = self.get_parameter( 'direct' )
        if direct:
            i.append( ".DIRECT\n")


        # Write out the *OPTIMZE section if necessary
        if geomopt:
            i.append( "*OPTIMIZE\n" )

            opt_order = self.get_parameter( 'opt_order' )
            if ( opt_order == "First Order" ):
                i.append( ".1STORDER\n" )
            elif( opt_order == "Second Order" ):
                i.append( ".2NDORDER\n" )
            
            optiter = int( self.get_parameter( 'opt_iter' ) )
            i.append( ".MAX IT\n" )
            i.append( " %d\n" % optiter )
            
            opt_conv = self.get_parameter( 'opt_conv' )
            if ( opt_conv == "Default" ):
                pass
            elif( opt_conv == "Baker" ):
                i.append( ".BAKER\n" )
            elif ( opt_conv == "Manual" ):
                # Energy 
                optconvE = self.get_parameter( 'opt_convE' )
                optconvE = fortranfloat( optconvE )
                i.append( ".ENERGY\n" )
                i.append( "%s\n" % optconvE )
                # Geometry
                opt_convgrad = self.get_parameter( 'opt_convgrad' )
                opt_convgrad = fortranfloat( opt_convgrad )
                i.append( ".GRADIENT\n" )
                i.append( "%s\n" % opt_convgrad )
                # Step Norm
                opt_convstep = self.get_parameter( 'opt_convstep' )
                opt_convstep = fortranfloat( opt_convstep )
                i.append( ".STEP T\n" )
                i.append( "%s\n" % opt_convstep )

            preopt = self.get_parameter( 'preopt' )
            if preopt:
                preoptbasis = self.get_parameter( 'preopt_basis' )
                i.append( ".PREOPT\n" )
                i.append( " 1\n" )
                i.append( "%s\n" % preoptbasis )

                
        # Write out the WAVEFUNCTION section.
        i.append( "**WAVEFUNCTION\n" )
        title = self.get_title()
        i.append( ".TITLE\n" )
        i.append ( " %s \n" % title )
        
        method = self.get_parameter( 'method' )
        if ( method == "HF" ):
            i.append( ".HF\n" )
        elif ( method == "DFT" ):
            i.append( ".DFT\n" )
            functional = self.get_parameter( "dft_functional" )
            i.append( " %s\n" % functional )


        # SCF INPUT SECTION
        if ( method == "HF" ):
            i.append( "*SCF INPUT\n" )
            i.append( ".THRESHOLD\n" )
            thresh = self.get_parameter( 'scf_thresh' )
            thresh = fortranfloat( thresh )
            i.append( " %s\n" % thresh )
            i.append( ".MAX DIIS\n" )
            mxdiis = self.get_parameter( 'diis_maxcyc' )
            i.append( " %u\n" % mxdiis )
            
        # DFT INPUT SECTION
        if ( method == 'DFT' ):
            i.append( "*DFT INPUT\n" )
            partitioning = self.get_parameter( "dft_partitioning" )
            i.append( ".GRID TYPE\n" )
            i.append( " %s \n" % partitioning )
            accuracy = self.get_parameter( "dft_accuracy" )
            i.append( ".%s \n" % accuracy )
            
        # CONFIGURATION INPUT SECTION
        i.append( "*CONFIGURATION INPUT\n" )
        spin = self.get_parameter( "spin" )
        i.append( ".SPIN MULTIPLICITY\n")
        i.append( " %u \n" % spin )

        # ORBITAL INPUT
        if ( method == "HF" ):
            i.append( "*ORBITAL INPUT\n" )
            guess = self.get_parameter( 'guess' )
            i.append( ".MOSTART\n" )
            i.append( " %s \n" % guess )

        # END INPUT HERE
        i.append( "*END OF INPUT" )

        return i

    def __setup_keyword_basis(self):
        """ Define all of the 'keyword' basis sets that are supported by Dalton
        """
        #Set up the keyword basis sets for Dalton
        m = self.basis_manager
        m.define_keyword_basis('STO-3G',['h','he','li',' be','b','c','n','o','f','ne',
                                        'na','mg','al','si','p','s','cl','ar',
                                        'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                        'ga','ge','as','se','br','kr',
                                        'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd'],ecp=0)
        
        m.define_keyword_basis('6-31G',['h','he','li',' be','b','c','n','o','f','ne',
                                        'na','mg','al','si','p','s','cl','ar',
                                        'zn'],ecp=0)
        
        m.define_keyword_basis('cc-pVDZ',['h','he','li',' be','b','c','n','o','f','ne',
                                        'al','si','p','s','cl','ar',
                                        'ca',
                                        'ga','ge','as','se','br','kr' ],ecp=0)

        m.define_keyword_basis('cc-pVTZ',['h','he','li',' be','b','c','n','o','f','ne',
                                        'al','si','p','s','cl','ar',
                                        'ca',
                                        'ga','ge','as','se','br','kr' ],ecp=0)
        
        m.define_keyword_basis('cc-pVQZ',['h','he','li',' be','b','c','n','o','f','ne',
                                        'al','si','p','s','cl','ar',
                                        'ca',
                                        'ga','ge','as','se','br','kr' ],ecp=0)

        # ECP basis sets
        m.define_keyword_basis('ecp-sdd-DZ',['li','be','b','c','n','o','f','ne',
                                           'na','mg','al','si','p','s','cl','ar',
                                           'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn',
                                           'ga','ge','as','se','br','kr',
                                           'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag','cd',
                                           'in','sn','sb','te','i','xe',
                                           'cs','ba','la',
                                           'hf','ta','w','re','os','ir','pt','au','hg',
                                           'tl','pb','bi'],ecp=1)


#     def get_comment(self,comment):
#         """ Return a list with the comments
#         """
#         return comment

#     def set_comment(self,comment):
#         """ Return a list with the comments
#         """
#         self.comment = comment



class DALTONCalcEd(QMCalcEd):

    def __init__(self,root,calc,graph,**kw):
        apply(QMCalcEd.__init__, (self,root,calc,graph), kw)

        # Associate helpfile with widget
        viewer.help.sethelp(self,'MoleculeTab')
        
#        self.tasks = [MENU_ENER, MENU_GRAD, MENU_OPT]
            #"numerical force constants",
            #"analytical force constants",
            #"polarisability",
            #"hyper polarisability",
            #"magnetisability",
            #"Raman intensities",
            #"infrared intensities",
            #"UV/Vis intensities"]
 #        self.theories[MENU_ENER] = [
#              "RHF", "UHF", "MP2", "B3LYP", "UB3LYP", 
#              "BLYP", "UBLYP", "SVWN", "USVWN", 
#              "HCTH", "UHCTH", "FT97", "UFT97"]
#         self.theories[MENU_GRAD] = [
#              "RHF", "UHF", "MP2", "B3LYP", "UB3LYP", 
#              "BLYP", "UBLYP", "SVWN", "USVWN", 
#              "HCTH", "UHCTH", "FT97", "UFT97"]
#         self.theories[MENU_OPT] = [
#              "RHF", "UHF", "MP2", "B3LYP", "UB3LYP", 
#              "BLYP", "UBLYP", "SVWN", "USVWN", 
#              "HCTH", "UHCTH", "FT97", "UFT97"]

        # methods
        self.methods = [ "HF","DFT" ]

        self.guess = [ "EWMO", "HUCKEL", "H1DIAG" ]
#         self.scf_methods = {}
#         self.scf_methods[MENU_ENER] = [
#              "RHF", "UHF", "GVB", "DFT", "UDFT" ,
#              "Direct RHF", "Direct UHF", "Direct GVB", "Direct DFT", "Direct UDFT"]
#         self.scf_methods[MENU_GRAD] = [
#              "RHF", "UHF", "GVB", "DFT", "UDFT" ,
#              "Direct RHF", "Direct UHF", "Direct GVB", "Direct DFT", "Direct UDFT"]
#         self.scf_methods[MENU_OPT] = [
#              "RHF", "UHF", "GVB", "DFT", "UDFT" ,
#              "Direct RHF", "Direct UHF", "Direct GVB", "Direct DFT", "Direct UDFT"]


        #DFT options
        self.dft_functionals = [
             "BLYP", "B3LYP", "B3LYP-G", "BP86", "B3P86", "CAMB3LYP" ]
        self.dft_grids = ["COARSE", "NORMAL", "FINE", "ULTRAF"]
        #self.dft_radialgrids = ["default","Euler-MacLaurin","Mura-Knowles"]
        #self.dft_angulargrids = ["default","Lebedev-Laikov","Gauss-Legendre"]
        #self.dft_lebedevpoints =[6,14,26,38,50,74,86,110,146,170,194,230,266,
        #                         302,350,434,590,770,974,1202]
        #self.dft_weights = ["Becke","MHL","SSF","MHL4SSF","MHL8SSF"]
        self.dft_partitioning = ["BECKE","BECKEORIG","SSF","LMG","GC2"]
        #self.dft_jbas = ["A1DGAUSS","A2DGAUSS","DEMON","AHLRICHS"]

        # Geometry Optimisation stuff
        self.optorder = [ "First Order", "Second Order" ]
        self.opt_conv = [ "Default", "Baker", "Manual" ]

        # For the pre-opt option, need to get a list of the valid basis sets
        # so get the basis manager from the calculation object and query it for
        # the supported basis sets for all elements. Unfortunately, there is
        # no way to udpate the basis sets once the preoptbasis_tool has been created
        # so the list of preopt basis sets will always contain all the supported basis
        # - not just those the are supported for the molecule in hand as one would want.
        
        basism = self.calc.basis_manager
        #molecule = self.calc.get_input( 'mol_obj' )
        #elements = []
        # build up a list of the elements
        #for atom in molecule.atom:
        #    if ( atom.symbol not in elements ):
        #        elements.append( atom.symbol )
        #self.preoptbasis = basism.available_basis_sets( elements )
        self.preoptbasis = basism.known_keyword_basis_sets

        #self.postscf_methods = {}
        #self.postscf_methods[MENU_ENER] = [
        #     "None", "MCSCF", "MP2", "MP3", 
        #     "CCSD", "CCSD(T)", "Direct CI", "MRDCI",
        #     "Direct MP2" ]
        #self.postscf_methods[MENU_GRAD] = [
        #     "None", "MCSCF", "MP2", "MP3", 
        #     "Direct MP2"]
        #self.postscf_methods[MENU_OPT] = [
        #     "None", "MCSCF", "MP2", "MP3",
        #     "Direct MP2"]
        #self.guess_options = ["Compute","Dumpfile","GETQ"]
#        self.compute_options = ["atoms","hcore","minguess","extguess","atorb"]
        #scf_rhf = ["RHF","B3LYP" ,"BLYP" ,"SVWN" ,"HCTH" ,"FT97"]
        #scf_uhf = ["UHF","UB3LYP","UBLYP","USVWN","UHCTH","UFT97"]

        #self.optcoord_opts = [ "Z-Matrix","Cartesian" ]
        #self.optbfgs_opts = ["default","BFGS","BFGSX"]
        #self.optrfo_opts = ["on","off"]

        self.submission_policies = [ LOCALHOST, "SSH","Nordugrid", "Globus"]

        #Create the tools used in the Molecule tab title, spin & charge created in QM.
        self.comment_tool = TextFieldTool(self,'comment','Comment', width=50 )
        
        #self.task_tool = SelectOptionTool(self,'task','Task',self.tasks,command=None)

        #Used to specify task
        #self.tasktoolvalue = self.task_tool.widget.getvalue() 

        self.checkspin_widget = Tkinter.Button(self.interior(),
                                             text = 'Check Spin',
                                             command = self.__CheckSpin)
        self.symmetry_tool = BooleanTool(self,'symmetry','Use Symmetry')

        mol_obj = self.calc.get_input('mol_obj')
        # need to propagate the default basis back

        self.basis_manager = self.calc.basis_manager
        
        self.basis_tool = BasisTool(self,'basis','ECP','default_basis',
                                    molecule=mol_obj,basis_manager=self.basis_manager)


        ## Create the tools used in the Theory tab

        # Variable to hold the last method for the method group
        self.oldmethod = None
        self.methodtools = {}
        # Create a dictionary of tools that will be needed in each method
        self.hftools = {}
        self.dfttools = {}

        self.methodtools['HF'] = self.hftools
        self.methodtools['DFT'] = self.dfttools


        self.method_tool = SelectOptionTool(self,'method',
                                               'Method',
                                               self.methods,
                                               self.__changemethod)
        self.geomopt_tool = BooleanTool(self,'geomopt','Optimise Geometry',self.__optgeom )
        self.direct_tool = BooleanTool(self,'direct','Direct')

        # Will we need a huge list with every possible tool?
        # HF tools
        self.diismaxcyc_tool = IntegerTool(self,'diis_maxcyc','Max. DIIS cycles',0)
        self.balloon.bind( self.diismaxcyc_tool.widget, 'Max. number of SCF convergence cycles that will be undertaken' )
        self.hftools['diismaxcyc'] = self.diismaxcyc_tool
        self.scfthreshold_tool = FloatTool(self,'scf_thresh','Threshold',mini=0.0, maxi = 1)
        self.hftools['scfthresh'] = self.scfthreshold_tool
        self.guess_tool = SelectOptionTool( self, 'guess', 'Guess Vectors', self.guess )
        self.hftools['guess'] = self.guess_tool

        # DFT tools
        self.dftfunctional_tool = SelectOptionTool(self,'dft_functional','Functional',self.dft_functionals)
        self.dfttools['dftfunctional'] = self.dftfunctional_tool
        self.dftaccuracy_tool = SelectOptionTool(self,'dft_accuracy','Grid setting',self.dft_grids)
        self.dfttools['dftaccuracy'] = self.dftaccuracy_tool
#        self.dftweightscheme_tool = SelectOptionTool(self,'dft_weights',
#                                                     'DFT weighting scheme',
#                                                     self.dft_weights)
        self.dftpartitioning_tool = SelectOptionTool(self,'dft_partitioning',
                                                     'DFT partitioning scheme',
                                                     self.dft_partitioning)
        self.dfttools['dftpartitioning'] = self.dftpartitioning_tool
        
        # This group will hold the tools that are to be configured for each
        # of the various scf methods and geometry optimisations options
        # Each method has a dictionary that can be used to reference the individual
        # tools when they need to be packed/forgotten
        # As maingroup will be used differently, it is created with the other tools
        #method = self.calc.get_parameter("method")
        #self.maingroup = Pmw.Group(self.interior(), tag_text=method)
        # For some reason I can't fathom, this doesn't work


        # Create all the tools for controlling geometry optimisations
        self.optorder_tool = SelectOptionTool( self, 'opt_order', 'Order of the optimisation', self.optorder )
        self.balloon.bind( self.optorder_tool.widget, 'Calculate analytical Hessian matrix at each step (second order) or not (first order)' )
        self.optiter_tool = IntegerTool( self,'opt_iter', 'Max Iterations', 0 )
        self.balloon.bind( self.optiter_tool.widget, 'Max. number of geometry optimisation steps that will be taken' )
        self.optconv_tool = SelectOptionTool( self, 'opt_conv',
                                              'Conversion Control',
                                              self.opt_conv,
                                              self.__optconv )
        self.balloon.bind( self.optconv_tool.widget, 'Specify the convergence criteria for the geometry optimisation' )
        
        self.optconvE_tool = FloatTool(self,'opt_convE','Energy',mini=0.0, maxi = 1.0E-6)
        self.optconvgrad_tool = FloatTool(self,'opt_convgrad','Gradient',mini=0.0, maxi = 1.0E-5)
        self.optconvstep_tool = FloatTool(self,'opt_convstep','Step Norm.',mini=0.0 )
        self.preopt_tool = BooleanTool( self,'preopt', 'Pre-optimise structure', self.__preopt )
        self.balloon.bind( self.preopt_tool.widget, 'Pre-optimise molecule in a different basis set first' )
        self.preoptbasis_tool = SelectOptionTool( self, 'preopt_basis', 'with basis:', self.preoptbasis )
        


        #Create the tools used in the Properties tab
        
        # Create a notebook for the different order properties
        self.prop_notebook = Pmw.NoteBook(
            self.interior(),
            hull_width = self.width,
            hull_height = self.height,
            createcommand=None,
            raisecommand=None,
            lowercommand=None)


        #Create the tools used for the Job tab
        #self.jobname_tool = TextFieldTool(self,'job_name','Job Name')
        self.dalfilename_tool = TextFieldTool(self,'dalfilename','.dal filename')
        self.balloon.bind( self.dalfilename_tool.widget, 'The name of the .dal file that holds the dalton directives' )
        self.molfilename_tool = TextFieldTool(self,'molfilename','.mol filename')
        self.balloon.bind( self.molfilename_tool.widget, 'The name of the .mol file that holds the molecular coordinates' )
        
#        self.hostname_tool = SelectOptionTool(self,'hostname',  'Host name',
#                                              self.hostnames, command=self.__sethost)
        #self.hostname = self.hostname_tool.widget.getvalue()# get the hostname for the below tool      
#        self.submission_tool = SelectOptionTool(self,'submission','Job Submission',
#                                                self.submissionpolicies[self.hostname])
#        self.username_tool = TextFieldTool(self,'username','User Name')
#        self.daltonexe_tool = FileTool(self,'dalton_script','Dalton script', action='open', command=self.__update_script )
#        self.balloon.bind( self.daltonexe_tool.widget, 'Specify the location of the dalton script to run the job' )
#        self.workdir_tool = ChangeDirectoryTool(self,'workdir','Working Directory')
#        self.balloon.bind( self.workdir_tool.widget, 'The directory where the results will be copied back to' )
#jmht


        self.setscratch_tool = BooleanTool(self,'setscratch','Change Scratch Directory',command=self.__setscratch)
        self.balloon.bind( self.setscratch_tool.widget, 'Specify the directory where the job will run' )
        self.scratchdir_tool = ChangeDirectoryTool(self,'scratchdir','Scratch Directory')
        self.keepscratch_tool = BooleanTool(self,'keepscratch','Keep Scratch')
        self.balloon.bind( self.keepscratch_tool.widget, 'Don\'t delete the scratch directory at the end of the job' )
        
        self.setbasis_tool = BooleanTool(self,'setbasis','Add Basis Directory',command=self.__setbasis)
        self.balloon.bind( self.setbasis_tool.widget, 'Specify an additional directory to be searched for basis sets' )
        self.basisdir_tool = ChangeDirectoryTool(self,'basisdir','Basis Directory')

        self.inputviewer = Pmw.ScrolledText(self.interior(),
                                            labelpos = 'n',
                                            label_text="Dalton Input File Viewer",
                                            borderframe = 1,
                                            columnheader = 1,
                                            Header_foreground = 'blue',
                                            #Header_background = 'yellow',
                                            #text_padx = 4,
                                            #text_pady = 4,
                                            Header_padx = 4,
                                            )
        

        self.LayoutToolsTk()

        # Must initialise tools after layout due to problems with the maingroup group
        # - it can't be created with the other tools as, although it packs in the right place
        # the tools packed inside it never appear
        self.__initialisetools()

        # Add the menu command to summarise the results
        self.menu.addmenuitem('View','command',
                     'View a summary of results',
                     command = lambda s=self: s.summarise_results(),
                     label = 'Results Summary')
        # flag to check if we already have a summary editor open
        self.summaryeditor=None


    def ViewInput(self):
        """Drag out the input file and show in a text widget."""
        input = self.calc.get_input( 'all_input' )
        if input == None:
            self.Info( "No input file available currently" )
        else:
            textview = self.textview
            textview.configure(text_state="normal",title="Input Listing")
            textview.clear()
            for a in input:
                textview.insert('end',a)
            textview.configure(text_state="disabled")
            textview.show()

    def EditInput(self):
        """Check if there is an input, if there is make sure we are
           not editing it before firing up an editor.
        """

        self.calc.WriteInput(nowrite=1) # Update the input
        
        input = self.calc.get_input('input_file')
        if input == None:
            self.Info("No input file available currently")
        else:
            if self.inputeditor:
                self.inputeditor.withdraw()
                self.inputeditor.show()
                return
            else:
                self.inputeditor = InputEd(self.interior(),
                                           self.calc,
                                           self,
                                           data=input,
                                           onsave=self._InputEditorSaveCmd)
                return 

    def _InputEditorSaveCmd(self):
        """The commands to be carried out when the use hits "Save" in the Input editor
           returns the name of the file to write out.
        """

        # Make sure we write out the mol input file
        self.calc.WriteInput( only_mol=1 )
        return self.calc.get_parameter('dalfilename') + '.dal'
        
#     def ViewOutput(self):
#         """Drag out the output file and show in a text widget."""
#         output = self.calc.get_output('all_output')
#         if output == None:
#             self.Info("No output file available currently")
#         else:
#             textview = self.textview
#             textview.configure(text_state="normal",title="Job Listing")
#             textview.clear()
#             for a in output:
#                 textview.insert('end',a)
#             textview.configure(text_state="disabled")
#             textview.show()

    def LowerPage(self,pagename):
        """ This method is called each time one of the tabs in the notebook is lowered and calls
            the relevant functions to write the input files and then
            updates the input window in the job tab accordingly.
        """

        self.calc.WriteInput( nowrite=1 )
        job_name = self.calc.get_parameter( "job_name" )

        self.inputviewer.configure( Header_state = 'normal' )
        self.inputviewer.component('columnheader').delete(1.0,END)
        self.inputviewer.component('columnheader').insert('1.0', job_name)
        self.inputviewer.component('columnheader').tag_add("job_name",1.0,END)
        self.inputviewer.component('columnheader').tag_config("job_name",justify="center")
        self.inputviewer.configure( Header_state = 'disabled' )

        dinput = self.calc.get_input( "all_input" )
        self.inputviewer.clear()
        
        if input:
            self.inputviewer.configure( text_state = 'normal' )
            for line in dinput:
                self.inputviewer.insert('end',line)
            self.inputviewer.configure( text_state = 'disabled' )
        else:
            print "Error displaying input"

    def summarise_results( self ):
        """ Get a list with the interesting results and then display
            it in the window. If we don't have an output buffer to display
            ask for a file that the user would like to get the results from
        """
        
        output = self.calc.get_output( "dalton_output" )

        if ( output == None ):
            # No output from calc, so we need to ask the users for an output file
            jobname = self.calc.get_parameter('job_name')
            workdir = self.calc.get_parameter('directory')
            fname = tkFileDialog.askopenfilename( initialdir = workdir,
                                                 filetypes=[ ( "Dalton output Files","*.out"),("All Files","*.*") ] )
            if len(fname) == 0:
                # User didn't select a file
                return 1

            #summary = DaltonOutputReader( ofile = fname )
            summary = ['THIS NEEDS TO BE FIXED']

        else:
            #summary = DaltonOutputReader( olist = output )
            summary = ['THIS NEEDS TO BE FIXED']

        try:
            if self.summaryeditor:
                try:
                    self.summaryeditor.withdraw()
                    self.summaryeditor.show()
                    return
                except:
                    print "Help! I\'ve lost my summary editor!"
            else:
                data = summary.list_summary()
                self.summaryeditor = Editor(self.interior(),title="summary",data=data)
                return
            
        except AttributeError,e :
            print 'No results to summarise: %s' % e
            return
    
    def LayoutToolsTk(self):
        """Place the widgets belonging to the tools (ChargeTool etc)
           The tools have already been created to this is just responsible
           for laying them out.
        """

        #Add Molecule tab
        page = self.notebook.add('Molecule',tab_text='Molecule')
        
        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Molecule')
        viewer.help.sethelp(tab,'Molecule Tab')
        
        page.optgroup = Pmw.Group(page,tag_text="Options")
        page.optgroup.pack(expand='yes',fill='both')
        page.basisgroup = Pmw.Group(page,tag_text="Basis Selector")
        page.basisgroup.pack(expand='yes',fill='both')

        self.title_tool.widget.pack(in_=page.optgroup.interior())
        self.comment_tool.widget.pack(in_=page.optgroup.interior())
        #self.task_tool.widget.pack(in_=page.optgroup.interior())
        #self.scfmethod_tool.widget.pack(in_=page.optgroup.interior())
        self.charge_tool.widget.pack(in_=page.optgroup.interior())
        self.spin_tool.widget.pack(in_=page.optgroup.interior())
        self.checkspin_widget.pack(in_=page.optgroup.interior())
        self.symmetry_tool.widget.pack(in_=page.optgroup.interior())

        Pmw.alignlabels([self.charge_tool.widget, self.spin_tool.widget])
        self.basis_tool.widget.pack(in_=page.basisgroup.interior())

        #Add Theory tab
        page = self.notebook.add('Theory',tab_text='Theory')

        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Theory')
        viewer.help.sethelp(tab,'Theory Tab')
        
        page.controlgroup = Pmw.Group(page,tag_text="Main")
        page.controlgroup.pack(expand=0,fill='x', side='top')
        self.method_tool.widget.pack(in_=page.controlgroup.interior())
        self.geomopt_tool.widget.pack(in_=page.controlgroup.interior())
        self.direct_tool.widget.pack(in_=page.controlgroup.interior())

        method = self.calc.get_parameter("method")
        self.maingroup = Pmw.Group(page, tag_text=method)
        self.maingroup.pack(expand=1,fill='both')
        #self.maingroup.pack(in_=page,expand=1,fill='both')
        
        # TEMPORARY hack
        page.maingroup = self.maingroup
        
        # Now go through the tools for each type and pack them
        # RHF tools
        self.diismaxcyc_tool.widget.pack(in_=page.maingroup.interior())
        self.diismaxcyc_tool.SetParent(page.maingroup.interior())
        self.scfthreshold_tool.widget.pack(in_=page.maingroup.interior())
        self.scfthreshold_tool.SetParent(page.maingroup.interior())
        self.guess_tool.widget.pack(in_=page.maingroup.interior())
        self.guess_tool.SetParent(page.maingroup.interior())

        # DFT tools
        self.dftfunctional_tool.widget.pack(in_=page.maingroup.interior())
        self.dftfunctional_tool.SetParent(page.maingroup.interior())
        self.dftaccuracy_tool.widget.pack(in_=page.maingroup.interior())
        self.dftaccuracy_tool.SetParent(page.maingroup.interior())
        self.dftpartitioning_tool.widget.pack(in_=page.maingroup.interior())
        self.dftpartitioning_tool.SetParent(page.maingroup.interior())


        # Layout the Optimisation tools
        # The daddy frame that all else packs into and itself packs into the maingroup frame
        #self.optgroup = Pmw.Group(self.maingroup.interior(), tag_text="Geometry Optimisation" )
        self.optgroup = Pmw.Group( page, tag_text="Geometry Optimisation" )

        page.optconvframe = Tkinter.Frame( self.optgroup.interior() )
        page.optconvframe.pack( in_= self.optgroup.interior(),side='top')

        self.optorder_tool.widget.pack( in_ = page.optconvframe )
        self.optiter_tool.widget.pack( in_ = page.optconvframe )
        
        self.optconv_tool.widget.pack( in_ = page.optconvframe )
        self.optconv_tool.SetParent( page.optconvframe )
        self.optconvE_tool.SetParent( page.optconvframe )
        self.optconvgrad_tool.SetParent( page.optconvframe )
        self.optconvstep_tool.SetParent( page.optconvframe )

        page.preoptframe =  Tkinter.Frame( self.optgroup.interior() )
        page.preoptframe.pack( in_ = self.optgroup.interior() )
        self.preopt_tool.widget.pack( in_ = page.preoptframe, side = 'left' )
        self.preoptbasis_tool.SetParent( page.preoptframe )

        # Add Properties tab
        page = self.notebook.add('Properties',tab_text='Properties')
        
        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Properties')
        viewer.help.sethelp(tab,'Properties Tab')
        
        self.prop_notebook.pack(in_=page,expand=1, fill='both')
        page = self.prop_notebook.add('Prop1',tab_text='First Order')
        button = Tkinter.Button(page,text="Hello")
        button.pack()
        page = self.prop_notebook.add('Prop2',tab_text='Second Order')
        button = Tkinter.Button(page,text="there")
        button.pack()
        page = self.prop_notebook.add('Prop3',tab_text='Third Order')
        button = Tkinter.Button(page,text="Dalton")
        button.pack()
        page = self.prop_notebook.add('Prop4',tab_text='Fourt Order')
        button = Tkinter.Button(page,text="Users")
        button.pack()


        #Add Job tab
        page = self.notebook.add('Job',tab_text='Job')

        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Job')
        viewer.help.sethelp(tab,'Job Tab')
        
        page.jobgroup = Pmw.Group(page,tag_text="Job Group")
        page.jobgroup.pack(side='top',expand='yes',fill='both')

        self.molfilename_tool.widget.pack(in_=page.jobgroup.interior())
        self.dalfilename_tool.widget.pack(in_=page.jobgroup.interior())
#        self.daltonexe_tool.widget.pack(in_=page.jobgroup.interior())
#        self.workdir_tool.widget.pack(in_=page.jobgroup.interior())

        self.submission_frame = Tkinter.Frame(page.jobgroup.interior())
        self.submission_frame.pack()
        self.submission_tool = SelectOptionTool(self,'submission','Job Submission',
                                                self.submission_policies)
        self.submission_config_button = Tkinter.Button(self.submission_frame,
                                                       text='Configure...',
                                                       command=self.open_jobsub_editor)
        self.submission_tool.widget.pack(in_=self.submission_frame,side='left')
        self.submission_config_button.pack(side='left')#

        # The frame & tools to set the scratch directory
        page.scratchframe = Tkinter.Frame(page.jobgroup.interior())
        page.scratchframe.pack(in_=page.jobgroup.interior(),side='top')
        self.setscratch_tool.SetParent( page.scratchframe )
        self.setscratch_tool.widget.pack( in_=page.scratchframe, side='top' )
        self.scratchdir_tool.SetParent( page.scratchframe )

        self.keepscratch_tool.widget.pack( in_=page.jobgroup.interior() )

        # The frame & tools to set the basis directory
        page.basisframe = Tkinter.Frame(page.jobgroup.interior())
        page.basisframe.pack(in_=page.jobgroup.interior(),side='top')
        self.setbasis_tool.SetParent( page.basisframe )
        self.setbasis_tool.widget.pack( in_=page.basisframe, side='top' )
        self.basisdir_tool.SetParent( page.basisframe )

#        self.username_tool.widget.pack(in_=page.jobgroup.interior())
#        self.molfilename_tool.widget.grid(in_=page.jobgroup.interior(), row=0, column=0, sticky='w' )
#        self.dalfilename_tool.widget.grid(in_=page.jobgroup.interior(), row=0, column=1 )
#        self.workingdirectory_tool.widget.grid(in_=page.jobgroup.interior(), row=1, columnspan=2)

#        self.jobname_tool.widget.pack(in_=page.jobgroup.interior())
#        self.hostname_tool.widget.pack(in_=page.jobgroup.interior())
#        self.submission_tool.widget.pack(in_=page.jobgroup.interior())

        # Input file viewer / editor?
        self.inputviewer.pack(in_=page, expand=1,fill="both")
        

    def EditCoordinates(self,model=None):
        """Open a coordinate editor window
        This differs from the generic one only in that the variables can
        have keywords associated (e.g. type 3)
        """
        if self.calc.editing:
            print 'Calculation is already being edited'
        else:
            self.calc.editing = 1
            mol_name = self.calc.get_input('mol_name')
            mol_obj = self.calc.get_input('mol_obj')
            self.zme = ZME(self.root,
                           model=mol_obj,
                           reload_func=self.reload_for_zme,
                           update_func=self.update_for_zme,
                           v_key=1)


    def __initialisetools(self):
        """Initialise any tools and variables that effect the defaults that are displayed.
        """

        # Set the current directory as the work directory
#        cwd = os.getcwd()
#        self.calc.set_parameter('workdir',str(cwd))
#        self.workdir_tool.UpdateWidget()

#         # Try and find the dalton script
#         script = self.__get_script()
#         if not script:
#             self.Info("The location of your dalton script could not be determined\n" +
#                       "Please set the location of the script in the job editor or\n" +
#                       "ensure that the dalton script is in your path.")
#         else:
#             self.calc.set_parameter( 'dalton_script', script )

        #self.daltonexe_tool.UpdateWidget()
        
        #HACKs for demo
        # Wipe out all the tools we created
        for toold in self.methodtools.values():
            for tool in toold.values():
                tool.Forget()
        self.__changemethod('HF')

    def __get_script(self):
        """ Try and find a dalton script to use.
            We first query the defaults dictionary to see if the user has
            set a script there, otherwise we use the find_exe method in paths.
            We either return the script or None if we can't find one
        """

        global defaults,find_exe

        # Create a job and use this to get the script
        script = defaults.get_value('dalton_script')
        if script:
            print "Using dalton script from ccp1guirc file: %s" % dalton_script
            return script
        else:
            print "No dalton_script set in rc file - checking in environment"
            script = find_exe( 'dalton' )
            if script:
                print "Found dalton script: %s" % script
                return script
            else:
                print "Cannot find a dalton script!"
                return None
                
    def __CheckSpin(self):
        for tool in self.tools:
            tool.ReadWidget()
        self.calc.CheckSpin()

    def __changemethod(self,method):
        """ Show or hide the tools in the method group
        """
        
        self.maingroup.configure(tag_text = method)

        # Forget the old tools
        if self.oldmethod:
            for tool in self.methodtools[self.oldmethod].values():
                tool.Forget()

        # Show the new ones...
        for tool in self.methodtools[method].values():
            tool.Pack()

        self.oldmethod = method
        
    def __setscratch(self):
        """ The user has clicked the Boolean tool to indicate that they want so
            specify the scratch directory, so show / hide the relevant tools.
            The first time this scipt is called it runs the dalton script with
            the -h flag and parses the output to get the current location of the
            scratch directory.
        """


        scratch = self.calc.get_parameter( 'scratchdir' )

        if ( scratch == 'UNSET' ):
            # This is the first time we've been called so try and
            # get the current scratch directory from the dalton script
            from jobmanager import ccp1gui_subprocess
            dalton_script = self.calc.get_parameter( 'dalton_script' )
            cmd = dalton_script + " -h"
            p = ccp1gui_subprocess.Pipe(cmd)
            code = p.run()

            gotscratch = None
            if p.error:
                print 'Error locating scratch directory '+str(p.error)
            else:
                tmpre = re.compile( ".*TMPDIR.*" )
                for line in p.output:
                    if tmpre.match( line ):
                        gotscratch = 1
                        fields = string.split( line )
                        scratchdir = fields[-1]
                        self.calc.set_parameter( 'scratchdir', scratchdir )

            if ( not gotscratch ):
                # Set to cwd - better than nowt...
                self.calc.set_parameter( 'scratchdir', '.' )
                
            self.scratchdir_tool.UpdateWidget()
        
        # From here on we have been called at least once before
        # so just show or hide the relevant tool
        self.setscratch_tool.ReadWidget()
        scratch = self.calc.get_parameter('setscratch')
        if scratch :
            self.scratchdir_tool.Pack( side = 'top' )
        else:
            self.scratchdir_tool.Forget()

    def __setbasis(self):
        """ The user has clicked the Boolean tool to indicate that they want so
            specify an additional directory, so show / hide the relevant tools.
        """

        # Make sure the widgets been read
        self.setbasis_tool.ReadWidget()

        keepbasis = self.calc.get_parameter( 'setbasis' )
        
        if keepbasis :
            #self.basisdir_tool.Pack( side = 'left' )
            self.basisdir_tool.Pack( side = 'top' )
        else:
            self.basisdir_tool.Forget()

    def __optgeom( self ):
        """ The user has click on the optimise button so we need to show/hide
            the frame containing the optimisation tools.
        """

        # Need to read the widget as the ReadWidget command has been overidden by this one
        opt = self.geomopt_tool.ReadWidget()
        #opt = self.calc.get_parameter( 'geomopt' )

        if opt:
            self.optgroup.pack( expand = 1, fill = 'both' )
        else:
            self.optgroup.forget()

    def __optconv( self, conv ):
        """ Hide or display the options to change the convergence thresholds depending on whether the
            user has opted to specify them manually or use the Baker scheme
        """
        
        # Forget all the tools
        self.optconvE_tool.Forget()
        self.optconvgrad_tool.Forget()
        self.optconvstep_tool.Forget()
        

        # Getting lazy and assuming the widget has been read and the parameter updated...
        if ( conv == 'MANUAL' ):
            self.optconvE_tool.Pack()
            self.optconvgrad_tool.Pack()
            self.optconvstep_tool.Pack()

    def __preopt( self ):
        """ Hide or display the options to change the convergence thresholds depending on whether the
            user has opted to specify them manually or use the Baker scheme
        """
        # Need to read the widget as the ReadWidget command has been overidden by this one
        preopt = self.preopt_tool.ReadWidget()

        if preopt:
            self.preoptbasis_tool.Pack( side = 'left' )
        else:
            self.preoptbasis_tool.Forget()
        
 
    def __sethost(self,host):
        """Update the submission types for the particular host.
        """
        self.submission_tool.SetItems(self.submissionpolicies[host])

def copycontents(to,fro):
    """Used to update an object by copying in the contents from another"""
    c = to.__class__
    d1 = c.__dict__
    try:
        d2 = fro.__dict__
    except AttributeError:
        d2 = {}
    for k in d2.keys():
        to.__dict__[k] = fro.__dict__[k]

            
if __name__ == "__main__":

    # This bit is needed if you would like to run dalton.py as a standalone - i.e. for
    # testing purposes - and sets up a 'dummy environment' so that all the relevant
    # dependancies are satisfied

    from dalton import *
    from objects.zmatrix import *
    from jobmanager import *
    model = Zmatrix()
    atom = ZAtom()
    atom.symbol = 'C'
    atom.name = 'C'
    model.insert_atom(0,atom)
    atom = ZAtom()
    atom.symbol = 'H'
    atom.name = 'H'
    atom.coord = [ 1.,0.,0. ]
    model.insert_atom(1,atom)
    atom = ZAtom()
    atom.symbol = 'H'
    atom.name = 'H1'
    atom.coord = [ 1.,1.,0. ]
    model.insert_atom(1,atom)

    root=Tk()
    calc = DALTONCalc()
    calc.set_input('mol_obj',model)
    jm = JobManager()
    je = JobEditor(root,jm)

    calc2 = copy.deepcopy(calc)

    vt = DALTONCalcEd(root,calc,None,job_editor=je)
    root.mainloop()

