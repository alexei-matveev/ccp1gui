#
#    This file is part of the CCP1 Graphical User Interface (ccp1gui)
# 
#   (C) 2002-2006 CCLRC Daresbury Laboratory
# 
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
# 
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
"""Implements the GAMESS-UK specific calculation (Calc) and
calculation editor (CalcEd) classes
"""

# import python modules
import os
import sys
import socket
import glob

# import external modules
import Tkinter
import Pmw
import tkFileDialog

# import internal modules
from calc import Calc,CalcError
from calced import CalcEd
import jobmanager
import tools
import viewer.help
from viewer.defaults import defaults
from viewer.paths import paths


LOCALHOST = socket.gethostname()


class GenericCalc(Calc):
    """GAMESS-UK specifics."""
    def __init__(self, **kw):

        
        Calc.__init__(self,**kw)

        self.debug = None
        self.set_program('Generic')
        self.set_title('This file was generated by the CCP1 GUI')

        # Just use some sensible defaults
        self.set_parameter("job_name","unknown")
        self.set_parameter("input_files",[])
        self.set_parameter("output_files",[])
        self.set_parameter("copy_directory",False)

        # These are job parameters but we deal with them as calculation
        # parameters here so we can use the widgets from tools
        self.set_parameter("stdin",'')
        self.set_parameter("stdout",'')
        self.set_parameter("stderr",'')
        self.set_parameter("arguments",'')

    def get_editor_class(self):
        return GenericCalcEd

    def WriteInput(self,filename=None):
        """Write the SMEAGOL input file"""

        return None

    def makejob( self, **kw ):
        """
        Construct the sequence of job steps
        """

        #
        #  Need to decide what kind of job run
        # 
        job = self.get_job()
        if not job:
            job = self.create_job()

        if not job:
            raise CalcError, "Generic makejob no job returned!"

        jobtype = job.jobtype
        
        # Run job from the specified directory
        directory = job.get_parameter('local_directory')
        if not directory:
            directory = paths['user']

        os.chdir(directory)
        print "job running from directory: %s" % directory

        # Default values for all jobs - may be changed below
        job_name = self.get_parameter("job_name")
        job.name    = job_name

        executable = job.get_parameter("executable")
        if not executable:
            raise CalcError,"GenericCalc job needs an excutable to run!"

        # Get any of stdin,stdout, stderr & job arguments that may have been
        # set by the widget
        stdin = self.get_parameter( 'stdin' )
        if stdin:
            job.set_parameter( 'stdin', stdin )
        stdout = self.get_parameter( 'stdout' )
        if stdout:
            job.set_parameter( 'stdout', stdout )
        stderr = self.get_parameter( 'stderr' )
        if stderr:
            job.set_parameter( 'stderr', stderr )
        arguments = self.get_parameter( 'arguments' )
        if arguments:
            # Convert to a list
            if type(arguments) == str:
                arguments = arguments.split()
            job.set_parameter( 'arguments', arguments )
            

        # Block of code to tweak the job depending on how it is being run
        if jobtype == LOCALHOST:
            job_desc = 'Running Job on %s' % LOCALHOST
        elif jobtype == 'RMCS':
            job_desc = 'Running Job with RMCS'
        elif jobtype == 'Nordugrid':
            job_desc = 'Running Job on Nordugrid'
        elif jobtype == 'Globus':
            job_desc = 'Running Job with Globus'

        job.clear_steps()

        # Copy out all the input files
        inputs = self.get_parameter("input_files" )
        for f in inputs:
            directory,filename = os.path.split( f )
            print "got dir,file %s,%s" % (directory,filename)
            job.add_step( jobmanager.COPY_OUT_FILE,
                          'transfer input: %s' % f,
                          local_filename=f,
                          remote_filename=filename)

        # Just run the application
        #stdin_file = files[0]
        job.add_step(
            jobmanager.RUN_APP,
            job_desc,
            stdin_file=None
            )

        if not jobtype == LOCALHOST:
            # Determine if copying directory or individual files
            if self.get_parameter( "copy_directory" ):
                # Copying back the whole directory
                remote_directory = job.get_parameter("remote_directory")
                if not remote_directory:
                    raise CalcError,"GenericCalc needs a remote_directory name to copy it back!"

                job.add_step(
                    jobmanager.COPY_BACK_DIRECTORY,
                    'recover outputs',
                    remote_directory=remote_directory
                    )
            else:
                # Add a separate job step for each file
                outputs = self.get_parameter( "output_files" )
                for f in outputs:
                    info = 'recovering file ' + f
                    job.add_step(
                        jobmanager.COPY_BACK_FILE,
                        info,
                        remote_filename=f
                        )
                
        job.add_tidy(self.endjob)
        return job

    def set_job_defaults(self,job):
        """Set any default parameters for calculations with this type of job
           This method should be overwritten (if need be) in any derived class.
        """
        if job.jobtype == LOCALHOST:
            pass
        else:
            pass
        return None

    def endjob(self,code=0):
        """This function is executed in the main thread"""

        return
        #directory = self.get_parameter("local_directory")
        #if self.debug:
        #    print 'running endjob in directory: %s - code=' % (directory,code)
        # 
        #ed = self.get_editor()
        #ed.Info("Got the files back!")



class GenericCalcEd(CalcEd):

    def __init__(self,root,calcobj,graph,**kw):


        CalcEd.__init__(self,root,calcobj,graph,**kw)

        self.submission_policies = [ LOCALHOST, "SSH", "Loadleveler", "RMCS", "Nordugrid", "Globus"]

        # For the editor, the default is to copy back the whole directory
        self.calc.set_parameter( 'copy_directory', True )
        self.LayoutToolsTk()

        # initialise tools
        for tool in self.tools:
            tool.UpdateWidget()

    def AddInputFile(self):
        """Add a file to the list to be exported
        """

        oldfile = None
        olddir = None
        filepath = tkFileDialog.askopenfilename(initialfile=oldfile,
                                              initialdir=olddir)
        if len(filepath) == 0:
            # User didn't select owt
            return None
        else:
            all = self.inputFileList.get()
            # convert from list to tuple
            files = []
            for f in all:
                files.append(f)

            # Now add the new file
            files.append( filepath )
            self.inputFileList.setlist( files )

            # Update the calculation file list
            self.calc.set_parameter("input_files", files )
            
            return None

    def DelInputFile(self):
        """ Remove a file from the list to be exported
        """
        toRemove = self.inputFileList.getcurselection()

        all = self.inputFileList.get()
        files = []  # need to convert from tuple to a list
        for m in all:
            files.append( m )
        for f in toRemove:
            files.remove( f )
        self.inputFileList.setlist( files )
        
        # Update the calculation file list
        self.calc.set_parameter("input_files", files )
        
        return

    def AddOutputFile(self):
        """Add a file to the list to be copied back
        """
                
        toadd = self.outputFileEntry.get()
        outputs = self.calc.get_parameter( "output_files" )
        outputs.append( toadd )
        self.outputFileList.setlist( outputs )
        self.outputFileEntry.delete(0,'end')

    def DelOutputFile(self):
        """ Remove a file from the list to be exported
        """
        toRemove = self.outputFileList.getcurselection()
        # Get pointer to the list
        outputs = self.calc.get_parameter( "output_files" )
        for mach in toRemove:
            outputs.remove( mach )
        self.outputFileList.setlist( outputs )
            

    def ToggleOuputFrame(self):
        """ Show or hide the frame to select files to bring back
        """

        show = self.directoryToggleVar.get()
        if show:
            self.outputFileFrame.forget()
            self.calc.set_parameter( "copy_directory",True )
        else:
            self.outputFileFrame.pack( side='left' )
            self.calc.set_parameter( "copy_directory",False )

        
    def LayoutToolsTk(self):
        """
        Create and layout the tools
        """

        #Add Job tab
        page = self.notebook.add('Job',tab_text='Job')

        # Associate helpfile with notebook frame
        tab = self.notebook.tab('Job')
        viewer.help.sethelp(tab,'Job Tab')
        
        page.jobgroup = Pmw.Group(page,tag_text="Job Group")
        page.jobgroup.pack(side='top',expand='yes',fill='both')

        # For naming the job
        self.jobname_tool = tools.TextFieldTool(self,'job_name','Job Name')
        self.jobname_tool.widget.pack(in_=page.jobgroup.interior())
        self.balloon.bind( self.jobname_tool.widget,
                           'Specify the prefix for all output files' )

        
        # Frame for selecting the type of job
        self.submission_frame = Tkinter.Frame(page.jobgroup.interior())
        self.submission_frame.pack()
        self.submission_tool = tools.SelectOptionTool(self,'submission','Job Submission',
                                                self.submission_policies)
        self.submission_tool.widget.pack(in_=self.submission_frame,side='left')
        self.submission_config_button = Tkinter.Button(self.submission_frame,
                                                       text='Configure...',
                                                       command=self.open_jobsub_editor)
        self.submission_config_button.pack(side='left')


        # Tools for specifying stdin, stdout, stderr and arguments
        self.stdin_tool = tools.TextFieldTool( self,
                                               'stdin',
                                               'stdin file' )
        self.balloon.bind( self.stdin_tool.widget,
                           'The file to use as standard input to the excutable' )         
        self.stdin_tool.widget.pack(in_=page.jobgroup.interior())
        
        self.stdout_tool = tools.TextFieldTool( self,
                                               'stdout',
                                               'stdout file' )
        self.balloon.bind( self.stdout_tool.widget,
                           'The file to route the standard output into' )         
        self.stdout_tool.widget.pack(in_=page.jobgroup.interior())
        
        self.stderr_tool = tools.TextFieldTool( self,
                                               'stderr',
                                               'stderr file' )
        self.balloon.bind( self.stderr_tool.widget,
                           'The file to route the standard error into' )
        self.stderr_tool.widget.pack(in_=page.jobgroup.interior())
        
        self.arguments_tool = tools.TextFieldTool( self,
                                               'arguments',
                                               'command-line arguments' )
        self.balloon.bind( self.arguments_tool.widget,
                           'The command-line arguments to the executable' )         
        self.arguments_tool.widget.pack(in_=page.jobgroup.interior())


        # Layout the tools to select the files to be used as input for the calculation
        self.inputFileFrame = Pmw.Group( self.interior(), tag_text='Files to transfer' )
        self.inputFileFrame.pack(in_=page.jobgroup.interior(),fill='both',expand=0)
        
        self.inputFileList = Pmw.ScrolledListBox(
            self.inputFileFrame.interior(),
            listbox_selectmode='extended',
            items=self.calc.get_parameter("input_files")
            )
        self.inputFileList.pack( side='left' )
        self.addInputFileButton = Tkinter.Button( self.inputFileFrame.interior(),
                                         text = 'Add',
                                         command = self.AddInputFile)
        self.addInputFileButton.pack( side='left' )
        self.delInputFileButton = Tkinter.Button( self.inputFileFrame.interior(),
                                        text = 'Del',
                                        command = self.DelInputFile)
        self.delInputFileButton.pack( side='left' )

        # Layout the tools for determining which files should be copied back
        self.outputFileGroup = Pmw.Group( self.interior(), tag_text='Files to Copy Back' )
        self.outputFileGroup.pack(in_=page.jobgroup.interior(),fill='both',expand=0)

        self.directoryToggleVar = Tkinter.IntVar()
        self.directoryToggle = Tkinter.Checkbutton(
            self.outputFileGroup.interior(),
            text="WholeDirectory",
            variable=self.directoryToggleVar,
            command=self.ToggleOuputFrame
            )
        self.directoryToggle.select()
        self.directoryToggle.pack()

        self.outputFileFrame=Tkinter.Frame( self.outputFileGroup.interior() )
        self.outputFileList = Pmw.ScrolledListBox(
            self.outputFileFrame,
            listbox_selectmode='extended',
            items=self.calc.get_parameter("output_files")
            )
        self.outputFileList.pack( side='left' )

        frameR = Tkinter.Frame( self.outputFileFrame )
        frameR.pack(side='left', fill='x', expand='1')
        
        self.outputFileEntry = Tkinter.Entry( frameR,
                                        width=20)
        self.outputFileEntry.pack( side='top', fill='x', expand='1' )
        bframe = Tkinter.Frame( frameR )
        bframe.pack( side='top' )

        self.addOutputFileButton = Tkinter.Button( bframe,
                                         text = 'Add',
                                         command = self.AddOutputFile)
        self.addOutputFileButton.pack( side='left' )
        
        self.delOutputFileButton = Tkinter.Button( bframe,
                                        text = 'Del',
                                        command = self.DelOutputFile)
        self.delOutputFileButton.pack( side='left' )
        


if __name__ == "__main__":

    root = Tkinter.Tk()
    #root.withdraw()
    calc = GenericCalc()
    jm = jobmanager.JobManager()
    je = jobmanager.JobEditor(root,jm)
    calced = GenericCalcEd(root,calc,None,job_editor=je)
    root.mainloop()
